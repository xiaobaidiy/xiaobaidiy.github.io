<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>四旋翼一--介绍</title>
      <link href="/2020/07/19/uav-1/"/>
      <url>/2020/07/19/uav-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以Vijay Kumar老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics-flight/home/welcome" target="_blank" rel="noopener">Robotics: Aerial Robotics</a>为参考，进行归纳整理。</p></blockquote><h1 id="四旋翼的结构"><a href="#四旋翼的结构" class="headerlink" title="四旋翼的结构"></a>四旋翼的结构</h1><p>四旋翼的结构如下图所示：<br><img src="1.png" alt=""><br>每个电机相对的那个电机旋转方向是相同的，而相邻的电机旋转方向是相反的，这样是为了抵消电机所产生的反力矩。通过控制四个电机的速度就可以控制UAV的位置和方向。</p><h1 id="自动化飞行的重要部分"><a href="#自动化飞行的重要部分" class="headerlink" title="自动化飞行的重要部分"></a>自动化飞行的重要部分</h1><p>在任何系统中，为了实现自动化控制，需要知道以下四个部分该如何实现：</p><ol><li>状态估计 – 估计UAV的位置和速度（包括旋转速度和角速度）</li><li>控制 – 控制电机并且正确的执行从而得到所期望的状态。</li><li>地图 – 有能力绘制周围环境的地图</li><li>规划 – 可以计算规划一个路径</li></ol><p>在室外我们可以使用GPS来定位并且导航，但是在室内就需要用到SLAM（Simultaneous Localization And Mapping）来定位并且绘制地图。如下图，如果机器人可以估计$d_1$，$d_2$，$d_3$，$d_1’$，$d_2’$，$d_3’$和$\Delta x$，那么就可以应用SLAM。<br><img src="2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Drone </tag>
            
            <tag> 四旋翼 </tag>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四元数</title>
      <link href="/2020/06/27/quaternion/"/>
      <url>/2020/06/27/quaternion/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：Krasjet的<a href="quaternion.pdf">四元数与三维旋转</a></p></blockquote><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>四元数可以写为如下形式：<br>$$<br>q=a+bi+cj+dk\quad (a,b,c,d\in \mathbb R)<br>$$其中：<br>$$<br>    i^2=j^2=k^2=ijk=-1<br>$$上面的公式就决定了四元数一切性质，四元数的定义和复数非常类似，唯一的区别就是四元数一共有三个虚部 $(i,j,k)$，而复数只有一个。</p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="模长"><a href="#模长" class="headerlink" title="模长"></a>模长</h2><p>一个四元数 $q=a+bi+cj+dk$ 的模长为：<br>$$<br>||q||=\sqrt{a^2+b^2+c^2+d^2}<br>$$如果用标量向量有序对的形式进行表示的话，$q=[s,\mathbf v]$ 的模长为：<br>$$<br>\begin{aligned}<br>||q||&amp;=\sqrt{s^2+||\mathbf v||^2} \\<br>&amp;=\sqrt{s^2+\mathbf v\cdot\mathbf v} \qquad (\mathbf v\cdot\mathbf v=||\mathbf v||^2)<br>\end{aligned}<br>$$</p><h2 id="四元数加法和减法"><a href="#四元数加法和减法" class="headerlink" title="四元数加法和减法"></a>四元数加法和减法</h2><p>与复数类似，四元数的加法只需要将分量相加就可以了。如果我们有两个四元数$q_1=a+bi+cj+dk$，$q_2=e+fi+gj+hk$，那么它们的和为：<br>$$<br>\begin{aligned}<br>q_1+q_2&amp;=a+bi+cj+dk+e+fi+gj+hk \\<br>&amp;=(a+e)+(b+f)i+(c+g)j+(d+h)k<br>\end{aligned}<br>$$减法也是同理：<br>$$<br>q_1-q_2=(a-e)+(b-f)i+(c-g)j+(d-h)k<br>$$如果四元数是以标量向量有序对形式定义的，比如说 $q_1=[s,\mathbf v]$，$q_2=[t,\mathbf u]$，那么：<br>$$<br>q_1\pm q_2=[s\pm t, \mathbf v\pm \mathbf u]<br>$$</p><h2 id="标量乘法"><a href="#标量乘法" class="headerlink" title="标量乘法"></a>标量乘法</h2><p>如果我们有一个四元数$q = a + bi + cj + dk$ 和一个标量$s$，那么它们的乘积为：<br>$$<br>\begin{aligned}<br>sq &amp;= s(a + bi + cj + dk)\\<br>&amp;= sa + sbi + scj + sdk)<br>\end{aligned}<br>$$四元数与标量的乘法是遵守交换律的，也就是说$sq=qs$。</p><h2 id="四元数乘法"><a href="#四元数乘法" class="headerlink" title="四元数乘法"></a>四元数乘法</h2><p>四元数之间的乘法比较特殊，它们是不遵守交换律的，也就是说一般情况下$q_1q_2 \neq q_2q_1$。除了交换律之外，我们经常使用的结合律和分配律在四元数内都是成立的。那么，如果有两个四元数$q_1 = a + bi + cj + dk$和$q_2 = e + f i + gj + hk$，那么它们的乘积为：<br>$$<br>\begin{aligned}<br>q_1q_2&amp;=(a + bi + cj + dk)(e + f i + gj + hk) \\<br>&amp;= ae + a f i + agj + ahk+\\<br>&amp;\quad bei + b f i2 + bgij + bhik+ \\<br>&amp;\quad cej + c f ji + cgj2 + chjk+ \\<br>&amp;\quad dek + d f ki + dgkj + dhk2<br>\end{aligned}<br>$$再根据下图的表格（表格中有颜色的格子代表着乘法交换律不成立）：<br><img src="1.png" alt=""><br>我们就能进一步简化四元数乘积的结果，于是就有了如下定理：对任意四元数 $q_1=[s,\mathbf v]$, $q_2=[t,\mathbf u]$，$q_1q_2$ 的结果是：<br>$$<br>q_1q_2=[st-\mathbf v\cdot\mathbf u,s\mathbf u+t\mathbf v+\mathbf v \times\mathbf u]<br>$$</p><h2 id="纯四元数"><a href="#纯四元数" class="headerlink" title="纯四元数"></a>纯四元数</h2><p>如果一个四元数能写成这样的形式：<br>$$<br>v=[0,\mathbf v]<br>$$那么我们称$v$是一个<strong>纯四元数</strong>，即仅有虚部的四元数。</p><h2 id="四元数的逆和共轭"><a href="#四元数的逆和共轭" class="headerlink" title="四元数的逆和共轭"></a>四元数的逆和共轭</h2><p>一个四元数 $q = a + bi + cj + dk$ 的<strong>共轭</strong>为 $q^\ast = a - bi - cj - dk$ 。如果用标量向量有序对的形式来定义的话，$q = [s,\mathbf v]$ 的共轭为$q^\ast = [s,−\mathbf v]$ 。共轭四元数的一个非常有用的性质就是：<br>$$<br>\begin{aligned}<br>qq^\ast&amp;=[s,\mathbf v]\cdot[s,−\mathbf v] \\<br>&amp;=[s^2+\mathbf v\cdot \mathbf v,0] \\<br>&amp;= s^2+x^2+y^2+z^2 \\<br>&amp;= ||q||^2<br>\end{aligned}<br>$$可以看到最终结果是一个实数，并且它是四元数模长的平方，而且满足 $qq^\ast=q^\ast q$。</p><p>我们定义$q^{-1}$是$q$的<strong>逆</strong>，并且有:<br>$$<br>\begin{aligned}<br>qq^{-1}&amp;=q^{-1}q=1 \qquad (q\neq0) \\<br>q^{-1}&amp;=\frac {q^*}{||q||^2}<br>\end{aligned}<br>$$</p><h1 id="四元数与3D旋转"><a href="#四元数与3D旋转" class="headerlink" title="四元数与3D旋转"></a>四元数与3D旋转</h1><p>定理：3D旋转公式（四元数型，正交情况）<br>当$\mathbf v_\bot$ 正交于旋转轴 $\mathbf u$ 时，旋转 $\theta$ 角度之后的 $\mathbf v_\bot’$ 可以使用四元数乘法来获得。令$v_\bot= [0, \mathbf v_\bot]$ ，$q = [cos(\theta), sin(\theta)\mathbf u]$，那么：<br>$$<br>v_\bot’=qv_\bot<br>$$</p><p>定理：3D旋转公式（四元数型，平行情况）<br>当$\mathbf v_{||}$ 平行于旋转轴 $\mathbf u$ 时，旋转 $\theta$ 角度之后的 $\mathbf v_{||}’$ 用四元数可以写为：<br>$$<br>v_{||}’=v_{||}<br>$$</p><p>定理：3D旋转公式（四元数型，一般情况）<br>任意向量$\mathbf v$沿着以单位向量定义的旋转轴$\mathbf u$旋转$\theta$度之后的$\mathbf v’$可以使用四元数乘法来获得。令$v=[0,\mathbf v]$，$q = [\frac{1}{2}cos(\theta), \frac{1}{2}sin(\theta)\mathbf u]$，那么：<br>$$<br>v’=qvq^*=qvq^{-1}<br>$$</p><p>定理：3D 旋转公式（矩阵型）<br>任意向量$\mathbf v$沿着以单位向量定义的旋转轴$\mathbf u$旋转$\theta$度之后的$\mathbf v’$可以使用矩阵乘法来获得。令 $a=cos(\frac{1}{2}\theta)$，$b=sin(\frac{1}{2}\theta)u_x$，$c=sin(\frac{1}{2}\theta)u_y$，$a=d=sin(\frac{1}{2}\theta)u_z$，那么：<br>$$<br>v’=<br>\begin{bmatrix}<br>1-2c^2-2d^2&amp;2bc-2ad&amp;2ac + 2bd \\<br>2bc + 2ad&amp;1-2b^2-2d^2&amp;2cd-2ab \\<br>2bd-2ac&amp;2ab+2cd&amp;1-2b^2-2c^2<br>\end{bmatrix} v<br>$$</p><h1 id="四元数，欧拉角和旋转矩阵的转换"><a href="#四元数，欧拉角和旋转矩阵的转换" class="headerlink" title="四元数，欧拉角和旋转矩阵的转换"></a>四元数，欧拉角和旋转矩阵的转换</h1><p>根据上一章我们知道四元数本身就代表了一种旋转，这一章我们将了解它和旋转矩阵以及欧拉角之间的关系。</p><h2 id="四元数转旋转矩阵"><a href="#四元数转旋转矩阵" class="headerlink" title="四元数转旋转矩阵"></a>四元数转旋转矩阵</h2><p>已知四元数 $q=(q_0,q_1,q_2,q_3)$ ，那么旋转矩阵为：<br>$$<br>R=\begin{bmatrix}<br>q_0^2+q_1^2-q_2^2-q_3^2 &amp; 2(q_1q_2-q_0q_3) &amp; 2(q_1q_3+q_0q_2) \\<br>2(q_1q_2+q_0q_3) &amp; q_0^2-q_1^2+q_2^2-q_3^2 &amp; 2(q_2q_3-q_0q_1) \\<br>2(q_1q_3-q_0q_2) &amp; 2(q_2q_3+q_0q_1) &amp;q_0^2-q_1^2-q_2^2+q_3^2<br>\end{bmatrix}<br>$$</p><h2 id="旋转矩阵转四元数"><a href="#旋转矩阵转四元数" class="headerlink" title="旋转矩阵转四元数"></a>旋转矩阵转四元数</h2><p>已知旋转矩阵：<br>$$<br>R=\begin{bmatrix}<br>r_{11}&amp;r_{12}&amp;r_{13} \\<br>r_{21}&amp;r_{22}&amp;r_{23} \\<br>r_{31}&amp;r_{32}&amp;r_{33}<br>\end{bmatrix}<br>$$那么求解四元数的方法可以从以下公式中得到：<br>$$<br>r_{11}+r_{22}+r_{33}=2q_0^2-1\Rightarrow q_0=\pm \frac{1}{2} \sqrt{1+r_{11}+r_{22}+r_{33}} \\<br>r_{11}-r_{22}-r_{33}=2q_1^2-1\Rightarrow q_1=\pm \frac{1}{2} \sqrt{1+r_{11}-r_{22}-r_{33}} \\<br>r_{22}-r_{11}-r_{33}=2q_2^2-1\Rightarrow q_2=\pm \frac{1}{2} \sqrt{1+r_{22}-r_{11}-r_{33}} \\<br>r_{33}-r_{11}-r_{22}=2q_3^2-1\Rightarrow q_3=\pm \frac{1}{2} \sqrt{1+r_{33}-r_{11}-r_{22}}<br>$$从这里我们可以得到好几组解，于是又有了如下限制：<br>$$<br>r_{12}+r_{21}=2(q_1q_2-q_0q_3)+2(q_1q_2+q_0q_3)=4q_1q_2 \\<br>r_{21}-r_{12}=2(q_1q_2+q_0q_3)-2(q_1q_2-q_0q_3)=4q_0q_3 \\<br>r_{13}+r_{31}=2(q_1q_3+q_0q_2)+2(q_1q_3-q_0q_2)=4q_1q_3 \\<br>r_{13}-r_{31}=2(q_1q_3+q_0q_2)-2(q_1q_3-q_0q_2)=4q_0q_2 \\<br>r_{23}+r_{32}=2(q_2q_3-q_0q_1)+2(q_2q_3+q_0q_1)=4q_2q_3 \\<br>r_{32}-r_{23}=2(q_2q_3+q_0q_1)-2(q_2q_3-q_0q_1)=4q_0q_1<br>$$这样只要得到$q_0$到$q_3$中的任意一个就能求出其他的值，假设我们先求$q_0$的值，则有：<br>$$<br>q_0=\pm \frac{1}{2} \sqrt{1+r_{11}+r_{22}+r_{33}} \\<br>q_1=\frac{r_{32}-r{23}}{4q_0} \\<br>q_2=\frac{r_{13}-r{31}}{4q_0} \\<br>q_3=\frac{r_{21}-r{12}}{4q_0}<br>$$从上式中可以看到，求得的四元数有两个，但是他们表示的是同一种旋转关系（一种是沿着$\mathbf u$转$\theta$角，另一种是沿着$-\mathbf u$转$-\theta$角）。至于先求$q_0$到$q_3$中的哪个值，在实际使用时应该全部一起求，看哪个值大，就选取哪个，以防止某一项在出现0时无法计算的情况。</p><h2 id="欧拉角转四元数"><a href="#欧拉角转四元数" class="headerlink" title="欧拉角转四元数"></a>欧拉角转四元数</h2><p>已知欧拉角：$\alpha$、$\beta$、$\gamma$，四元数为：<br>$$<br>q=\begin{bmatrix}<br>cos\frac{\gamma}{2} \\<br>0 \\<br>0 \\<br>sin\frac{\gamma}{2}<br>\end{bmatrix}<br>\begin{bmatrix}<br>cos\frac{\beta}{2} \\<br>0 \\<br>sin\frac{\beta}{2} \\<br>0<br>\end{bmatrix}<br>\begin{bmatrix}<br>cos\frac{\alpha}{2} \\<br>sin\frac{\alpha}{2} \\<br>0 \\<br>0<br>\end{bmatrix}=\begin{bmatrix}<br>cos\frac{\alpha}{2}cos\frac{\beta}{2}cos\frac{\gamma}{2}+sin\frac{\alpha}{2}sin\frac{\beta}{2}sin\frac{\gamma}{2} \\<br>sin\frac{\alpha}{2}cos\frac{\beta}{2}cos\frac{\gamma}{2}-cos\frac{\alpha}{2}sin\frac{\beta}{2}sin\frac{\gamma}{2} \\<br>cos\frac{\alpha}{2}sin\frac{\beta}{2}cos\frac{\gamma}{2}+sin\frac{\alpha}{2}cos\frac{\beta}{2}sin\frac{\gamma}{2} \\<br>cos\frac{\alpha}{2}cos\frac{\beta}{2}sin\frac{\gamma}{2}-sin\frac{\alpha}{2}sin\frac{\beta}{2}cos\frac{\gamma}{2}<br>\end{bmatrix}<br>$$</p><h2 id="四元数转欧拉角"><a href="#四元数转欧拉角" class="headerlink" title="四元数转欧拉角"></a>四元数转欧拉角</h2><p>已知四元数 $q=(q_0,q_1,q_2,q_3)$ ，那么欧拉角为：<br>$$<br>\begin{bmatrix}<br>\alpha \\<br>\beta \\<br>\gamma<br>\end{bmatrix}=<br>\begin{bmatrix}<br>atan2(2(q_0q_1+q_2q_3),1-2(q_1^2+q_2^2)) \\<br>arcsin(2(q_0q_2-q_1q_3)) \\<br>atan2(2(q_0q_3+q_1q_2),1-2(q_2^2+q_3^2))<br>\end{bmatrix}<br>$$但是当$\beta$角度为$\pm90$度时，四元数反向计算欧拉角时会出现奇点，是无法计算的。也就是出现了万向锁问题，这时候我们通常令$\alpha=0$，然后解出欧拉角的值。</p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四元数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波器计算无人机姿态</title>
      <link href="/2020/06/24/kalman-filter-imu-sensor-fusion/"/>
      <url>/2020/06/24/kalman-filter-imu-sensor-fusion/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：<a href="https://d1.amobbs.com/bbs_upload782111/files_50/ourdev_711905ORLKPP.pdf" target="_blank" rel="noopener">基于陀螺仪及加速度计信号融合的姿态角度测量</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇介绍卡尔曼滤波器的文章中说到，对于无人机的姿态计算，我们不能单独的用陀螺仪或者是加速度计来进行测量，而是需要将它们俩进行融合，那么这一讲我们就来看看如何用卡尔曼滤波器进行滤波融合。</p><h1 id="卡尔曼滤波融合过程"><a href="#卡尔曼滤波融合过程" class="headerlink" title="卡尔曼滤波融合过程"></a>卡尔曼滤波融合过程</h1><p>首先建立系统的状态方程和测量方程：<br><img src="1.png" alt=""><br>式中，$\varphi$是系统的真实角度，$b$是陀螺仪的零点偏移量，$\omega_{gyro}$为包含固定偏差的陀螺仪输出角速度，$\varphi_{acce}$为加速度计经处理后得到的角度值，$w_g$为陀螺仪测量噪声，$w_a$为加速度计测量噪声，$w_g$和$w_a$相互独立，此处假设二者为满足正态分布的白色噪声，令$T_s$为系统采样周期，得到离散系统的状态方程和测量方程：<br><img src="2.png" alt=""><br>并且系统过程噪声协方差矩阵$Q$以及测量误差的协方差矩阵$R$为：<br><img src="3.png" alt=""><br>式中，q_acce和q_gyro分别是加速度计和陀螺仪测量的协方差，其数值代表卡尔曼滤波器对其传感器数据的信任程度，值越小，表明信任程度越高。在该系统中陀螺仪的值更为接近准确值，因此取q_gyro的值小于q_acce的值。</p><p>此时，对应上一篇所介绍的卡尔曼滤波器的计算过程，我们现在已经知道了矩阵$A=\begin{bmatrix}1&amp;-T_s\\0&amp;1\end{bmatrix}$， 矩阵$B=\begin{bmatrix}T_s\\0\end{bmatrix}$，接下来我们只要给定一个初始化的系统状态$\hat x_0$以及它的方差$P_0$，还有干扰的协方差$Q$和$R$就可以带入公式计算了，具体计算过程请参考上一篇。下图是参考资料里用到的初始化参数，可以做一个参考：<br><img src="4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kalman Filter </tag>
            
            <tag> 卡尔曼滤波器 </tag>
            
            <tag> sensor fusion </tag>
            
            <tag> 无人机姿态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波器</title>
      <link href="/2020/06/21/kalman-filter/"/>
      <url>/2020/06/21/kalman-filter/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：Matlab video：<a href="https://www.mathworks.com/videos/understanding-kalman-filters-part-1-why-use-kalman-filters--1485813028675.html" target="_blank" rel="noopener">Understanding Kalman Filters</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了测量无人机的姿态，我们会用到一种传感器叫做IMU（Inertial Measurement Unit），它其中就包括了测量角速度的陀螺仪（Gyroscope）和测量角度的加速度计（accelerometer）。</p><p>但是，陀螺仪输出的是角速度，要通过积分才能获得角度，但是即使在零输入状态时，陀螺仪仍是有输出的，它的输出是白噪声和慢变随机函数的叠加，受此影响，在积分的过程中，必然会引进累计误差，积分时间越长，误差就越大。这时候，便需要加速度传感器的加入，利用加速度传感器来对陀螺仪进行校正。由于加速度传感器可以利用力的分解原理，通过重力加速度在不同轴向上的分量来判断倾角。同时，它没有积分误差，所以加速度传感器在相对静止的条件下，可以有效校正陀螺仪的误差。但在运动状态下，加速度传感器输出的可信度就要下降，因为它测量的是重力和外力的合力。</p><p>所以，为了准确的得到无人机的姿态，就需要将陀螺仪和加速度计的数据进行融合。最常用的就是卡尔曼滤波器（Kalman Filter），简称KF。</p><h1 id="卡尔曼滤波器的适用范围"><a href="#卡尔曼滤波器的适用范围" class="headerlink" title="卡尔曼滤波器的适用范围"></a>卡尔曼滤波器的适用范围</h1><p>为什么要使用卡尔曼滤波器呢？首先，它可以用于估算无法被直接测量的系统。举例来说，我们如何监控火箭发动机内部的温度呢？因为火箭发动机内部的温度非常高，传感器放进去就会被融化掉，所以只能把传感器放在发动机的外侧，这时就可以使用卡尔曼滤波器来估算内部的温度，从而间接得到我们想要的信息。<br><img src="1.png" alt=""><br>第二种情况就是在数据源有噪音干扰时，我们可以用KF来估计系统的状态。举例来说，我们如何准确的得出汽车行驶距离呢？首先车上有三种sensor，IMU，里程表和GPS。因为IMU会产生累计误差，里程表会受到路况的影响，而GPS的信号有时会被物体遮挡，这时我们就可以用KF将这三个测量值结合，最后得到汽车最优的估算位置。<br><img src="2.png" alt=""></p><h1 id="状态观察器"><a href="#状态观察器" class="headerlink" title="状态观察器"></a>状态观察器</h1><p>在了解KF之前，我们先了解一下什么是状态观察器（State Observers）。举一个例子，你不知道你的好朋友Timmy心情怎么样，你可以给她一个好吃的然后就可以通过她的表情来判断，所以状态观察可以帮助你估计你无法直接或测量的东西。我们接着刚才测量火箭发动机内部温度的例子来说，首先我们要给火箭发动机建立一个数学模型，因为给发动机的燃料量是已知的，将这个燃料量输入到数学模型中就可以得到一个估算的外部温度$\hat T_{ext}$以及一个估算的内部温度$\hat T_{in}$，于此同时我们也可以测出真实的火箭发动机外部的温度$T_{ext}$。但是在现实中，因为外界干扰以及传感器自身误差，测量值$T_{ext}$和理想值$\hat T_{ext}$肯定是不一样的。<br><img src="3.png" alt=""><br>因此我们的目的是让$T_{ext}$和$\hat T_{ext}$一致，这样的话$T_{in}$和$\hat T_{in}$就也是一样的。我们需要将$T_{ext}$和$\hat T_{ext}$的差值作为error反馈到数学模型中，于是问题就变成了如何选择控制器增益K使$T_{ext}$和$\hat T_{ext}$的误差最小化。<br><img src="4.png" alt=""><br>将模型写成数学表达式，如下图：<br><img src="5.png" alt=""></p><h1 id="最优状态估计器"><a href="#最优状态估计器" class="headerlink" title="最优状态估计器"></a>最优状态估计器</h1><p>从上一节介绍的状态观察器我们知道，在理想情况下只要数学模型通过修正后就可以使误差收敛到0，但是在现实情况中，实际物体会受到环境的干扰而且传感器还有测量误差，这就导致我们得到的$y_k$是有干扰的。所以，为了更加准确的表达实际物体的模型，需要给测量值加上测量误差$v_k$以及给物体加上环境干扰误差$w_k$，如下图：<br><img src="6.png" alt=""><br>$v$是均值为0，协方差为R的高斯分布：$v\sim N(0,R)$，$w$是均值为0，协方差为Q的高斯分布：$w\sim N(0,Q)$。</p><p>假设我们这个状态观察器是用来描述汽车行驶距离的，$x$代表的是汽车实际位置，$y$代表的是汽车的测量位置。首先我们可以通过数学模型计算出汽车在$\hat x_{k-1}$的位置，但由于汽车会受到环境的干扰，那么汽车的实际位置就可能是在$\hat x_{k-1}$附近，可以用一个概率分布图来表示。然后在下一个时刻汽车的实际位置就会在$\hat x_k$附近，并且概率分布的方差会比上一个时刻大，因为误差会累积。与此同时，传感器也会给我们一个测量值$y_k$，由于这个值也是有误差的，所以汽车的实际位置同样也可以用概率分布图来表示。现在我们就有了估算位置概率分布$\hat x_k$以及测量位置概率分布$y_k$，将这个两个概率函数相乘就得到了另一个概率函数，这个函数的均值就是最优估计值。<br><img src="7.png" alt=""></p><h1 id="卡尔曼滤波器"><a href="#卡尔曼滤波器" class="headerlink" title="卡尔曼滤波器"></a>卡尔曼滤波器</h1><p>卡尔曼滤波器其实就是最优状态估计器的一种，是不过它取最有估计值时并不是简单的将两个概率函数相乘，我们先看一下卡尔曼滤波器的方程式：<br>$$<br>\hat x_k=A\hat x_{k-1}+Bu_k+K_k(y_k-C(A\hat x_{k-1}+Bu_k))<br>$$<br>是不是感觉很熟悉，其实它就是下图所示的蓝色区域：<br><img src="8.png" alt=""><br>为了得到最优估计值$\hat x_k$，首先我们要得到根据数学模型得到的预测值$\hat x_k^-=A\hat x_{k-1}+Bu_k$，这个预测值是用上一时刻的最优估计值计算得出的，于是KF就可以进一步写为：<br>$$<br>\hat x_k=\hat x_k^-+K_k(y_k-C(\hat x_k^-))<br>$$<br>我们可以将KF的计算分为两个部分，第一部分是根据数学模型得到的预测值$\hat x_k^-$，第二部分是通过反馈对预测值进一步更新，最后就得到了最优估计值。</p><p>现在唯一的问题就是反馈增益$K_k$该如何决定。对于KF来说，它是动态的对$K_k$进行更改，当上一时刻得出的最优值更靠近预测值时，那么这一时刻它就更相信预测值，反之亦然。接下来我们来看KF的计算过程，首先是根据上一时刻系统的状态通过数学模型进行预测：<br>$$<br>\begin{aligned}<br>&amp;\hat x_k^-=A\hat x_{k-1}+Bu_k \\<br>&amp;P_k^- = AP_{k-1}A^T+Q<br>\end{aligned}<br>$$<br>$P_k^-$是$\hat x_k^-$的协方差，因此通过这一步我们就得到了预估状态的概率分布函数。接下来就要更新增益$K_k$，然后计算出最优估计值$\hat x_k$以及它的方差$P_k$：<br>$$<br>\begin{aligned}<br>&amp;K_k=\frac {P_k^-C^T}{CP_k^-C^T+R} \\<br>&amp;\hat x_k = \hat x_k^-+K_k(y_k-C\hat x_k^-) \\<br>&amp;P_k=(1-K_kC)P_k^-<br>\end{aligned}<br>$$<br><img src="9.png" alt=""><br>在这里我们讨论一下$K_k$的取值，当$P_k^-$等于0时，也就是说预测值$\hat x_k^-$的方差为0，所以它是100%可以被相信的，此时$K_k$等于0，最后就可以得到$\hat x_k=\hat x_k^-$，最优估计值就是预测值。反之，当$R$等于0时，也就是说测量值的方差为0，那么测量值就是100%可以被相信的，此时$K_k$等于$C^{-1}$，最后就可以得到$\hat x_k=y_k$。</p><p>KF也可以被用来做传感器融合，接着上述例子，为了增加测量的准确性，我们给车子又增加了传感器IMU，这时测量值就会变成一个2x1的向量，计算过程如下图：<br><img src="10.png" alt=""></p><p>将KF简单总结一下，首先它会通过一种方式将预测值和测量值进行融合，然后将这个结果作为这个时刻的最优解，然后判断这个最优解越靠近谁，在下个时刻就会给谁更多的权重就越相信谁。</p><h1 id="扩展卡尔曼滤波器"><a href="#扩展卡尔曼滤波器" class="headerlink" title="扩展卡尔曼滤波器"></a>扩展卡尔曼滤波器</h1><p>卡尔曼滤波器可以为线性系统提供最优的估计值，但是对于非线性系统则不适用。对于非线性系统，我们需要将系统近似转化为线性系统后再进行计算，这个就是扩展卡尔曼滤波器（Extended Kalman Filter，即EKF）。当系统是非线性时，系统状态方程则写为如下形式：<br>$$<br>\begin{aligned}<br>&amp;x_k=f(x_{k-1},u_k)+w_k \\<br>&amp;y_k=g(x_k)+v_k<br>\end{aligned}<br>$$<br>其中$f(x_{k-1},u_k)$和$g(x_k)$都是非线性函数。</p><p>接下来我们需要求出方程$f$和$g$的Jacobian矩阵，也就是它们对$x$的偏导数：<br>$$<br>\begin{aligned}<br>&amp;F=\frac {\partial f}{\partial x}|_{\hat x_{k-1},u_k} \\<br>&amp;G=\frac {\partial g}{\partial x}|_{\hat x_k}<br>\end{aligned}<br>$$<br>被线性化处理的系统就变成了这样:<br>$$<br>\begin{aligned}<br>&amp;\Delta x_k \approx F\Delta x_{k-1}+w_k \\<br>&amp;\Delta y_k \approx G\Delta x_k+v_k<br>\end{aligned}<br>$$<br>接下来计算EKF的过程就和KF一样了，先是进行预测：<br>$$<br>\begin{aligned}<br>&amp;\hat x_k^-=f(\hat x_{k-1},u_k) \\<br>&amp;P_k^- = FP_{k-1}F^T+Q<br>\end{aligned}<br>$$<br>然后再更新：<br>$$<br>\begin{aligned}<br>&amp;K_k=\frac {P_k^-G^T}{GP_k^-G^T+R} \\<br>&amp;\hat x_k = \hat x_k^-+K_k(y_k-g(\hat x_k^-)) \\<br>&amp;P_k=(1-K_kG)P_k^-<br>\end{aligned}<br>$$<br><img src="11.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kalman Filter </tag>
            
            <tag> 卡尔曼滤波器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂八--Jacobian Matrix</title>
      <link href="/2020/05/24/robot-arm-jacobian-matrix/"/>
      <url>/2020/05/24/robot-arm-jacobian-matrix/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料<a href="https://nrsyed.com/2017/12/10/inverse-kinematics-using-the-jacobian-inverse-part-2/" target="_blank" rel="noopener">Inverse kinematics using the Jacobian inverse</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前几讲我们所介绍的例子中，我们用到的都是用解析法来准确的求解IK问题，而这一讲中，我们将介绍一种数值法求解IK的方法，叫做<strong>Jacobian Matrix</strong>。用这种方法，我们不需要计算复杂的方程式，只要知道了手臂的结构，就可以通过不断迭代的方式来逼近我们的目标点。</p><h1 id="Jacobian-Matrix"><a href="#Jacobian-Matrix" class="headerlink" title="Jacobian Matrix"></a>Jacobian Matrix</h1><p>首先我们看Jacobian Matrix是什么样的,其中n是手臂joint的数量，x，y，z是手臂末端点的坐标位置：<br>$$<br>J=\begin{bmatrix}<br>\frac{\partial x}{\partial \theta_1}&amp;\frac{\partial x}{\partial \theta_2}&amp;\cdots&amp;\frac{\partial x}{\partial \theta_n} \\<br>\frac{\partial y}{\partial \theta_1}&amp;\frac{\partial y}{\partial \theta_2}&amp;\cdots&amp;\frac{\partial y}{\partial \theta_n} \\<br>\frac{\partial z}{\partial \theta_1}&amp;\frac{\partial z}{\partial \theta_2}&amp;\cdots&amp;\frac{\partial z}{\partial \theta_n} \\<br>\end{bmatrix}<br>$$</p><h2 id="Jacobian-Matrix的意义"><a href="#Jacobian-Matrix的意义" class="headerlink" title="Jacobian Matrix的意义"></a>Jacobian Matrix的意义</h2><p>我们发现Jacobian Matrix的每一列其实就是将手臂末端点坐标位置对每一个joint求偏导数。换句话说，Jacobian Matrix每一列的意义就是这个joint的变化对手臂末端点位置的影响或者说是变化率。举例来说，第一列指的就是joint 1发生的变化会对手臂末端点产生什么样的影响。然后我们将每个joint对手臂末端点的影响列在一个矩阵里，这个矩阵就是Jacobian Matrix。</p><p>我们知道对$y=f(x)$的函数求导，就会得到这个函数在各个x点处的斜率。当x变化很小时，我们就可以通过这个斜率来估算y的变化，可以写为$\Delta y=f’(x)\Delta x$。而Jacobian Matrix充当的就是这里$f’(x)$的角色，于是就有了如下关系：$\Delta r=J\Delta \theta$<br>$$<br>\begin{aligned}<br>&amp;\Delta r&amp;=\begin{bmatrix}<br>\Delta x \\<br>\Delta y \\<br>\Delta z<br>\end{bmatrix} &amp;=\begin{bmatrix}<br>\frac{\partial x}{\partial \theta_1}&amp;\frac{\partial x}{\partial \theta_2}&amp;\cdots&amp;\frac{\partial x}{\partial \theta_n} \\<br>\frac{\partial y}{\partial \theta_1}&amp;\frac{\partial y}{\partial \theta_2}&amp;\cdots&amp;\frac{\partial y}{\partial \theta_n} \\<br>\frac{\partial z}{\partial \theta_1}&amp;\frac{\partial z}{\partial \theta_2}&amp;\cdots&amp;\frac{\partial z}{\partial \theta_n} \\<br>\end{bmatrix}\begin{bmatrix}<br>\Delta \theta_1 \\<br>\Delta \theta_2 \\<br>\vdots \\<br>\Delta \theta_n \\<br>\end{bmatrix}\\<br>&amp;&amp;&amp;=\begin{bmatrix}<br>\frac{\partial x}{\partial \theta_1}\Delta \theta_1+\frac{\partial x}{\partial \theta_2}\Delta \theta_2+\cdots+\frac{\partial x}{\partial \theta_n}\Delta \theta_n \\<br>\frac{\partial y}{\partial \theta_1}\Delta \theta_1+\frac{\partial y}{\partial \theta_2}\Delta \theta_2+\cdots+\frac{\partial y}{\partial \theta_n}\Delta \theta_n \\<br>\frac{\partial z}{\partial \theta_1}\Delta \theta_1+\frac{\partial z}{\partial \theta_2}\Delta \theta_2+\cdots+\frac{\partial z}{\partial \theta_n}\Delta \theta_n<br>\end{bmatrix}\\<br>\end{aligned}<br>$$<br>通过这个等式，我们将每个joint对手臂末端点位置的影响都累加起来，就得到了最终x，y，z的变化量。</p><p>但是这个过程只解决了顺向运动学的问题，那么IK问题怎么解决呢？很简单，首先定义手臂末端需要移动的方向和大小$\Delta r$，然后在等式两边左乘Jacobian Matrix的逆矩阵，这样就得到了每个joint的变化量$\Delta \theta=J^{-1}\Delta r$。$J^{-1}$就相当于$\Delta r$对$\Delta \theta$的变化率，当$\Delta r$是指向目标点的向量时，就可以计算出到达目标点所需要的$\Delta \theta$，但是这个等式只有在$\Delta r$比较小的时候才能近似成立，所以我们需要一步一步的迭代，慢慢移动到目标点。然而，在绝大多数情况下Jacobian Matrix都是不可逆的，因此会用到pseudoinverse：$J^+=J^T(JJ^T)^{-1}$</p><h2 id="Jacobian-Matrix的建立"><a href="#Jacobian-Matrix的建立" class="headerlink" title="Jacobian Matrix的建立"></a>Jacobian Matrix的建立</h2><p>在了解了Jacobian Matrix的定义以及意义后，我们接下来看如何得到Jacobian Matrix。以一个平面3轴的手臂为例：<br><img src="1.png" alt=""><br>上面第一幅图中，如果只有手臂的第一个joint动，而其他的joint都不动的话，手臂末端点的运动轨迹就是那段弧形虚线，而那段切线就是当前手臂末端点对joint 1的偏导数，也就对应了我们Jacobian Matrix的第一列，以此类推。所以Jacobian Matrix就是这些切线的集合。</p><p>那我们该如何得到那条切线的向量呢？首先我们定义$r_e$是基坐标指向手臂末端点的向量，$r_j$是基坐标指向joint j的向量，$z_j$是joint j的旋转向量，那么$r_e-r_j$就是图中的黑色箭头。因为每一个joint所对应的那条切线永远都是垂直于$r_e-r_j$和$z_j$的，所以就可以用叉乘的方式得到那条切线的向量：$z_j\times(r_e-r_j)$，因此就可以写出我们的Jacobian Matrix：<br>$$<br>J=\begin{bmatrix}<br>(z_1\times(r_e-r_1))^T&amp;(z_2\times(r_e-r_2))^T&amp;\dots&amp;(z_n\times(r_e-r_n))^T<br>\end{bmatrix}<br>$$</p><p>在就得到了Jacobian Matrix后，就可以用它来解决IK问题了。其实，Jacobian Matrix提供了一种线性趋近的方式，当手臂的joint发生改变时Jacobian Matrix也发生改变。当$\Delta r$比较小时，这个方法就能比较准确的驱动手臂末端以直线移动到目标点，但是需要更多的迭代运算。当$\Delta r$比较大时，手臂末端就能更快的移动到目标点，但是移动过程中就不一定完全按照所期望的那条直线移动。因此，$\Delta r$大小也可以用来控制移动速度，但是这个速度与时间无关。</p><p>其实，手臂的控制不单单只有位置还有方向，为了将手臂末端的方向控制考虑进来，我们需要增加新的限制条件，首先要在$\Delta r$中增加手臂末端绕x，y，z轴旋转的转速，然后再在Jacobian Matrix中添加每个joint的转轴，最后可写为如下形式：<br>$$<br>\begin{aligned}<br>\Delta r&amp;=\left[\begin{array}{ccc|ccc}<br>\Delta x&amp;\Delta y &amp;\Delta z &amp;w_x &amp;w_y&amp; w_z<br>\end{array}\right]^T \\<br>J&amp;=\begin{bmatrix}<br>(z_1\times(r_e-r_1))^T&amp;(z_2\times(r_e-r_2))^T&amp;\dots&amp;(z_n\times(r_e-r_n))^T \\<br>\hline<br>z_1&amp;z_2&amp;\dots&amp;z_n<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><h2 id="Jacobian-Matrix的补充"><a href="#Jacobian-Matrix的补充" class="headerlink" title="Jacobian Matrix的补充"></a>Jacobian Matrix的补充</h2><p>最后，关于Jacobian Matrix的建立还有最后一点注意事项，上述我们介绍的都是手臂的joint是旋转的情况，然而手臂的joint还有可能是线性运动的情况，不同类型的joint在建立Jacobian Matrix时也不一样，区别如下：</p><table><thead><tr><th align="center"></th><th align="center">Prismatic</th><th align="center">Revolute</th></tr></thead><tbody><tr><td align="center">$\begin{bmatrix}\Delta x&amp;\Delta y&amp;\Delta z\end{bmatrix}^T$</td><td align="center">$z_j$</td><td align="center">$z_j\times(r_e-r_j)$</td></tr><tr><td align="center">$\begin{bmatrix}w_x&amp;w_y&amp;w_z\end{bmatrix}^T$</td><td align="center">$\begin{bmatrix}0&amp;0&amp;0\end{bmatrix}^T$</td><td align="center">$z_j$</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jacobian Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂七--轨迹规划实例</title>
      <link href="/2020/05/14/robot-arm-7/"/>
      <url>/2020/05/14/robot-arm-7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="任务概述"><a href="#任务概述" class="headerlink" title="任务概述"></a>任务概述</h1><p>机械手臂需要夹住放在桌子上的杯子，然后将杯子挂到墙上的杯架，位置参数以及手臂的DH参数如下图：<br><img src="1.png" alt=""><br><img src="2.png" alt=""></p><h1 id="条件设定"><a href="#条件设定" class="headerlink" title="条件设定"></a>条件设定</h1><ol><li>我们需要规划手臂将杯子从桌子上拿起然后放到杯架上的整个轨迹。为了让轨迹变得顺滑，我们可以先让手臂拿起杯子一小段距离到$f_{c_1}$，然后到达杯架前，调整到适当姿态，然后将杯子平移到杯架上，如下图所示：<br><img src="3.png" alt=""></li><li>我们要定义杯子在各点（$P_{0-f}$）的时间、坐标位置以及姿态。<br><img src="4.png" alt=""><br><img src="5.png" alt=""></li><li>我们就可以求出杯子在各点处相对于世界坐标的Transformation Matrix （$^0_CT$）<br><img src="6.png" alt=""></li><li>再推导出手臂末端点在各点处相对于世界坐标的Transformation Matrix （$^0_6T$）<br><img src="7.png" alt=""></li><li>从$^0_6T$得知$^0P_{6org}$在各点的位置和姿态。<br><img src="8.png" alt=""></li></ol><h1 id="以linear-function-with-parabolic-blends在Cartesian-space下规划轨迹"><a href="#以linear-function-with-parabolic-blends在Cartesian-space下规划轨迹" class="headerlink" title="以linear function with parabolic blends在Cartesian-space下规划轨迹"></a>以linear function with parabolic blends在Cartesian-space下规划轨迹</h1><ol><li>求出$^0P_{6org}$在各DOF（$X,Y,Z,\Phi_X,\Phi_Y,\Phi_Z$）每段的速度和加速度<br><img src="9.png" alt=""></li><li>建立并绘出各DOF在每个时间区段的轨迹<br><img src="10.png" alt=""></li><li>此时轨迹规划已经完成，接下来就要用IK计算出轨迹上所有设定点以及轨迹内插点的六轴转角（计算量很大）。以第二个via point为例：<br><img src="11.png" alt=""><br><img src="12.png" alt=""><br><img src="13.png" alt=""><br><img src="14.png" alt=""><br><img src="15.png" alt=""> </li><li>将解出的轨迹设定点以及轨迹内插点的六轴转角对各自的时间进行画图：<br><img src="16.png" alt=""> </li><li>将转角带入FK，画出杯子的坐标及姿态，已确认轨迹规划的正确性，同样以第二个via point为例：<br><img src="17.png" alt=""></li></ol><h1 id="以linear-function-with-parabolic-blends在joint-space下规划轨迹"><a href="#以linear-function-with-parabolic-blends在joint-space下规划轨迹" class="headerlink" title="以linear function with parabolic blends在joint-space下规划轨迹"></a>以linear function with parabolic blends在joint-space下规划轨迹</h1><ol><li>以IK先计算出各点的六轴转角<br><img src="18.png" alt=""></li><li>求出各轴（$\theta_1-\theta_6$）在每个时段的速度及加速度<br><img src="19.png" alt=""></li><li>建立各轴在每个时段的轨迹<br><img src="20.png" alt=""></li><li>以FK画出杯子对事件的轨迹，确认轨迹有通过设定点。<br><img src="21.png" alt=""></li><li>在Cartensian-space下和在joint-space下轨迹比较。<br><img src="22.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械手臂轨迹规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂六--线性与二次方程搭配的轨迹规划曲线</title>
      <link href="/2020/05/13/robot-arm-6/"/>
      <url>/2020/05/13/robot-arm-6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>上一讲中我们介绍了一种用三次多项式的方式来规划轨迹曲线的方式，但是在很多实际任务中我们需要用到直线轨迹。但是如果单纯的使用直线轨迹，那么在两段之间的中间点处速度是不连续的，为了解决这个问题，我们把直线两端修改为二次方程式，从而让速度变得平滑，如下图：<br><img src="1.png" alt=""></p><h1 id="规划方式"><a href="#规划方式" class="headerlink" title="规划方式"></a>规划方式</h1><p>规划的方式分为两段，直线段和二次多项式段：</p><ul><li>Linear段，是匀速的：<br>$$<br>\dot \theta=\frac{\theta_h-\theta_b}{t_h-t_b}=\dot \theta_{t_b}<br>$$</li><li>Parabolic段，是等加速的：<br>$$<br>\begin{aligned}<br>&amp;\theta(t)=\theta_0+\dot \theta_0t+\frac{1}{2}\color{red}{\ddot \theta}t^2 （这个是等加速度的位移公式）\\<br>&amp;\dot \theta(t)=\dot \theta_0+\color{red}{\ddot \theta}t \\<br>&amp;\dot \theta(t_b)=\color{red}{\ddot \theta}t_b（assume \space \dot \theta_0=0） \\<br>\end{aligned}<br>$$<br><img src="2.png" alt=""><br>因为直线段和二次多项式段的交界处的速度需要一样，所以可以得到如下结论：<br><img src="3.png" alt=""></li></ul><h2 id="对加速度-ddot-theta-的讨论"><a href="#对加速度-ddot-theta-的讨论" class="headerlink" title="对加速度$\ddot \theta$的讨论"></a>对加速度$\ddot \theta$的讨论</h2><p><img src="4.png" alt=""></p><h2 id="三种方式的比较"><a href="#三种方式的比较" class="headerlink" title="三种方式的比较"></a>三种方式的比较</h2><p><img src="5.png" alt=""></p><h1 id="多段Linear-Function-with-Parabolic-Blends"><a href="#多段Linear-Function-with-Parabolic-Blends" class="headerlink" title="多段Linear Function with Parabolic Blends"></a>多段Linear Function with Parabolic Blends</h1><p>假设，有一个路径规划，其中有n个中间点，然后用Linear Function with Parabolic Blends的方法将各个点串起来，但是实际的轨迹并没有经过中间点（黑色实线），如下图所示：<br><img src="6.png" alt=""></p><ul><li>轨迹中间线段$[\theta_i \space \theta_{i+1}]$的计算方式：<br><img src="7.png" alt=""></li><li>轨迹第一段的计算方法：<br>前面我们说过实际的轨迹并没有经过中间点，但是起始位置是必须要经过的，所以我们不能用计算中间线段的方式来计算起始点。这里假设起始位置速度为0，然后我们可以在$\theta_0$的后面插入一个假设的中间点$\theta_1$，并且它的位置是二次多项式所需时间$t_1$的一半（$t_{\theta_1}=\frac{1}{2}t_1$）。然后用以下方式计算：<br><img src="8.png" alt=""></li><li>轨迹最后一段的计算方法：<br>最后一段和第一段一样，假设最后速度为0，在$\theta_f$点前插入一个假设的中间点$\theta_n$，并且它的位置是二次多项式所需时间$t_n$的一半（$t_{\theta_n}=\frac{1}{2}t_n$）。然后用以下方式计算：<br><img src="9.png" alt=""></li></ul><h2 id="举例：一个RRR手臂"><a href="#举例：一个RRR手臂" class="headerlink" title="举例：一个RRR手臂"></a>举例：一个RRR手臂</h2><p><img src="10.png" alt=""><br><img src="11.png" alt=""><br><img src="12.png" alt=""><br><img src="13.png" alt=""></p><h1 id="多段Linear-Function-with-Parabolic-Blends的讨论"><a href="#多段Linear-Function-with-Parabolic-Blends的讨论" class="headerlink" title="多段Linear Function with Parabolic Blends的讨论"></a>多段Linear Function with Parabolic Blends的讨论</h1><ol><li>在真实系统中可以达到的加速度$\ddot \theta$取决于很多因素：<ul><li>电机的规格</li><li>手臂的姿态：手臂在不同状态下，各个joint所需要承受的torque不同。</li><li>手臂的动作状态：手臂在不同运行状态下，各个joint所需要承受的惯性力不同。</li></ul></li><li>路径规划没有通过中间点的解决方法：在原本的via points两边插入pseudo via points（橘色的点），让原本的via points落在linear段上，这样就会通过，如下图：<br><img src="14.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械手臂线性轨迹规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂五--轨迹规划</title>
      <link href="/2020/05/13/robot-arm-5/"/>
      <url>/2020/05/13/robot-arm-5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>机械手臂的轨迹规划就是说当手臂执行某一个操作时，比如说，从一个位置取某一物件然后移动到另一个位置，这段运动轨迹就需要我们来规划，规划的内容就包括位置、速度以及加速度随时间的变化。通常我们理想的轨迹都是平滑的曲线，其中包括起始点{$T_{initial}$}，很多的中间点{$T_{t_i}$}以及终点{$T_{final}$}。如果轨迹变化很大的话，那么在变化的那个点就需要手臂有很大的torque来改变运动状态，有时手臂可能做不到，而且会让整个运动过程看起来不流畅。<br><img src="1.png" alt=""></p><h1 id="轨迹规划"><a href="#轨迹规划" class="headerlink" title="轨迹规划"></a>轨迹规划</h1><p>轨迹的规划方式有两种，一种是在joint-space下进行，一种是在Cartesian-space下进行。接下来将分别介绍两种方法，以及它们的优缺点。</p><h2 id="Joint-space下的轨迹规划"><a href="#Joint-space下的轨迹规划" class="headerlink" title="Joint-space下的轨迹规划"></a>Joint-space下的轨迹规划</h2><p>在Joint-space下规划轨迹的方法如下：</p><ol><li>定义这段轨迹在空间中的起始点{$T_{initial}$}，中间点{$T_{t_i}$}以及终点{$T_{final}$}。</li><li>计算这些点的IK，得到在每个时间点$t_i$，手臂的每个joint所对应的角度。</li><li>对每一个joint都在其自己的角度坐标系下规划一条平滑的曲线。</li><li>计算FK，检查手臂末端点在Cartesian-space下轨迹的可行性（可能会碰到障碍物）。</li></ol><p>具体过程如下图：<br><img src="2.png" alt=""></p><blockquote><p>Note：<br>优点：计算量小，只需要计算起始点、中间点和终点的IK。<br>缺点：在空间中的运动轨迹不直观。</p></blockquote><h2 id="Cartesian-space下的轨迹规划"><a href="#Cartesian-space下的轨迹规划" class="headerlink" title="Cartesian-space下的轨迹规划"></a>Cartesian-space下的轨迹规划</h2><p>在Cartesian-space下规划轨迹的方法如下：</p><ol><li>定义这段轨迹在空间中的起始点{$T_{initial}$}，中间点{$T_{t_i}$}以及终点{$T_{final}$}。</li><li>对每一个手臂末端点的状态参数（$x,y,z,\theta_x,\theta_y,\theta_z$）规划一条平滑的曲线。</li><li>将规划好的手臂末端点状态的轨迹点计算IK，转换到joint-space下。</li><li>检查joint在joint-space下轨迹的可行性（有的joint的转动角度有限制或者角加速度太大手臂做不到）。</li></ol><p>具体过程如下图：<br><img src="3.png" alt=""></p><blockquote><p>Note：<br>优点：在空间中的运动轨迹比较直观。<br>缺点：计算量大，需要计算整个轨迹点的IK。</p></blockquote><h1 id="轨迹规划曲线—三次多项式"><a href="#轨迹规划曲线—三次多项式" class="headerlink" title="轨迹规划曲线—三次多项式"></a>轨迹规划曲线—三次多项式</h1><p>轨迹规划中平滑的曲线需要写成函数的形式，这样我们才能得到不同时刻的值。在这里我们用三次多项式（Cubic Polynomials）的形式来规划路径，也就是说，每两个中间点之间可以写成三次多项式的函数形式，不同轨迹区段[$t_i$ $t_{i+1}$]是不同的三次多项式。然后为了使整体的路径规划平滑，我们需要给相邻的两个区段增加限制条件，包括位置和速度（$\theta(t_i)$，$\theta(t_{i+1})$，$\dot\theta(t_i)$，$\dot\theta(t_{i+1})$）。<br><img src="4.png" alt=""></p><h2 id="解三次多项式"><a href="#解三次多项式" class="headerlink" title="解三次多项式"></a>解三次多项式</h2><ol><li><p>三次多项式的通式：<br>$$<br>\theta(\tilde t)=a_0+a_1\tilde t+a_2\tilde t^2+a_3\tilde t^3, 4\space unknown\space para: a_j \space _{j=0…3}<br>$$<br>每一个区段[$t_i$ $t_{i+1}$]都有一个这样的三次多项式，只不过每段的参数不同。</p></li><li><p>$\tilde t$的取值：<br>对每一个区段：$t\in[t_i,t_{i+1}]$<br>$\tilde t=t-t_i$，所以$\tilde t|_{t=t_i}=0$</p></li><li><p>增加边界条件：<br>首先当$t=t_i$和$t=t_{i+1}$时，这个三次多项式函数需要落在$\theta_i$和$\theta_{i+1}$上，所以有：<br>$$<br>\begin{aligned}<br>&amp;\theta(\tilde t|_{t=t_i})=\theta_i=\color{red}{a_0} \\<br>&amp;\theta(\tilde t|_{t=t_{i+1} })=\theta_{i+1}=a_0+a_1\Delta t+a_2\Delta t^2+a_3\Delta t^3 \\<br>\end{aligned}<br>$$<br>然后这个三次多项式函数在$t=t_i$和$t=t_{i+1}$时的速度也需要我们来设计，所以有：<br>$$<br>\begin{aligned}<br>&amp;\dot \theta(\tilde t|_{t=t_i})=\dot \theta_i=\color{red}{a_1} \\<br>&amp;\dot \theta(\tilde t|_{t=t_{i+1} })=\dot \theta_{i+1}=a_1+2a_2\Delta t+3a_4\Delta t^2 \\<br>\end{aligned}<br>$$</p></li><li><p>联立上面4个方程式最后解出：<br>$$<br>\begin{aligned}<br>&amp;\color{red}{a_2} = \frac{3}{\Delta t^2}(\theta_{i+1}-\theta_i)-\frac{2}{\Delta t}\dot \theta_i-\frac{1}{\Delta t}\dot \theta_{i+1} \\<br>&amp;\color{red}{a_3} = -\frac{2}{\Delta t^3}(\theta_{i+1}-\theta_i)+\frac{1}{\Delta t^2}(\dot \theta_{i+1}+\dot \theta_i)<br>\end{aligned}<br>$$</p></li><li><p>用Matrix的方式计算：<br><img src="5.png" alt=""></p></li></ol><h2 id="多段三次多项式"><a href="#多段三次多项式" class="headerlink" title="多段三次多项式"></a>多段三次多项式</h2><p>在上面的计算中，我们需要设计在边界的速度条件$\dot \theta_i$和$\dot \theta_{i+1}$，那么我们该如何设计呢？</p><ol><li>自己定义。不建议用这个方法，这样会使我们整个路径规划变得很复杂。</li><li>自动生成：<br>如果$\dot \theta_i$在$t_i$前后变号，那么$\dot \theta_i$就取0；<br>如果$\dot \theta_i$在$t_i$前后同号，那么$\dot \theta_i$就取前后两段速度的平均数；<br><img src="6.png" alt=""></li></ol><h3 id="举例：有一个中间点的路径规划"><a href="#举例：有一个中间点的路径规划" class="headerlink" title="举例：有一个中间点的路径规划"></a>举例：有一个中间点的路径规划</h3><p><img src="7.png" alt=""><br><img src="8.png" alt=""><br><img src="9.png" alt=""><br><img src="10.png" alt=""></p><h2 id="多段三次多项式通解"><a href="#多段三次多项式通解" class="headerlink" title="多段三次多项式通解"></a>多段三次多项式通解</h2><p>假设一共有N+1个点，其中有1个初始点，N-1个中间点和1个终点。那么我们一共就有N个三次多项式，每个三次多项式有4个未知参数，所以一共有4N个未知量。为了求解这4N个未知量，我们就需要4N个限制条件：</p><ul><li>每一段会有两个位置条件，所以一共有2N个位置条件；</li><li>每一个中间点会有一个速度条件和一个加速度条件，所以一共有2（N-1）个速度和加速度条件；</li><li>目前为止一共有4N-2个条件，那么最后两个条件我们可以限制起始点和终点点的速度或者是加速度，这样就有4N个条件了。</li></ul><h3 id="举例：一个RRR的机械手臂"><a href="#举例：一个RRR的机械手臂" class="headerlink" title="举例：一个RRR的机械手臂"></a>举例：一个RRR的机械手臂</h3><p>方法一：用三次多项式在Cartesian-space下规划路径：<br><img src="11.png" alt=""><br><img src="12.png" alt=""><br><img src="13.png" alt=""><br><img src="14.png" alt=""><br>方法二：用三次多项式在joint-space下规划路径：<br><img src="15.png" alt=""><br><img src="16.png" alt=""><br><img src="17.png" alt=""></p><h2 id="高阶多项式"><a href="#高阶多项式" class="headerlink" title="高阶多项式"></a>高阶多项式</h2><p>如果我们不但要规划位置和速度，还要规划加速度的话，我们就需要用到五次多项式，而不是四次多项式。因为位置、速度和加速度分别会产生2个条件，一共有6个条件，五次多项式有6个未知数。<br><img src="18.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械手臂轨迹规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂四--逆向运动学</title>
      <link href="/2020/05/11/robot-arm-4/"/>
      <url>/2020/05/11/robot-arm-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>上一讲介绍了正向运动学（Forward Kinematics），它的计算过程是给予$\theta_i$（可计算出$^{i-1}_iT$），然后求出手臂末端位置或坐标。相反，对于逆向运动学（Inverse Kinematics）来说，就是给予手臂末端位置或坐标，求得$\theta_i$。</p><h1 id="求解概念"><a href="#求解概念" class="headerlink" title="求解概念"></a>求解概念</h1><p>假设有一个6DOF的机械臂，未知的joint angles就有6个（$\theta_i$或$d_i$，$i=1,…,6$）。那么它的Transformation Matirx就可以写成这样的形式：<br>$$<br>^0_6T=<br> \left[<br>\begin{array}{ccc|c}<br>  &amp;^0_6R_{3\times3}&amp;&amp;^0P_{6 org 3\times1} \\<br>\hline<br>  0&amp;0&amp;0&amp;1<br>\end{array}<br>\right] _{4\times4}<br>$$<br>对于任何一个Transformation Matrix来说，它们都只有6个自由度，因为虽然旋转矩阵$R$里有九个数字，但是$\hat X, \hat Y, \hat Z$的长度为1，增加了3个限制条件，然后$\hat X, \hat Y, \hat Z$又要两两要垂直，又增加了3个限制条件，所以只有3个自由度，再加上移动向量$P$的3个未知数，一共就有6个自由度。为了解出这个Transformation Matrix，我们需要解出$R$和$P$，一共有12个非线性方程式，再加上6个限制条件，来解6个未知数。所以6自由度的机械臂是没有冗余的，需要用pieper准则来判断机械臂是否有解析解，后面会介绍。但是当机械臂大于6个自由度时，就会有冗余自由度，这时IK就有无数多的解，在实际应用中需要增加限制条件方能求出有效解。</p><h1 id="多重解"><a href="#多重解" class="headerlink" title="多重解"></a>多重解</h1><p>因为那12个方程式是非线性的，所以并不代表具有唯一解，机械手臂的解是由自身结构所决定的。比如，上一讲中提到的PUMA机械手臂（6 DOF），它的前3个DOF是用来控制手臂末端在空间中的位置，对于同一个位置它就有四组解，如下图：<br><img src="1.png" alt=""><br>同时，同一个位置下，手腕部位的转动姿态又有两组解：<br>$$<br>\begin{aligned}<br>&amp;\theta^{‘}_4 = \theta_4 + 180^\circ \\<br>&amp;\theta^{‘}_5 = -\theta_5 \\<br>&amp;\theta^{‘}_6 = \theta_6 + 180^\circ<br>\end{aligned}<br>$$<br>所以针对一些特定工作点，就有2x4=8组解。但是，有时因为手臂本身的几何限制或者空间限制，并不是任何一个解都可以用。当出现多组解时，我们就需要进行选择，选择的方式有：</p><ul><li>选择距离目前状态最近的解，这样最快，最省能。</li><li>选择避开障碍物的解，如果有障碍物就需要考虑进来。</li></ul><h1 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h1><p>求解Inverse Kinematics的方法有两种，<strong>解析法</strong>和<strong>数值法</strong>。解析法就是用代数（algebraic）计算Transformation Matrix并解方程的方法或着几何（geometric）法画图再运用三角函数来计算。而数值法就是是采用某种计算方法，如有限元法， 数值逼近法，插值法等得到的解，其<strong>正确性不如解析法</strong>可靠。目前大多数机械手臂都直接设计成有解析解的。</p><h2 id="举例：RRR机械手臂"><a href="#举例：RRR机械手臂" class="headerlink" title="举例：RRR机械手臂"></a>举例：RRR机械手臂</h2><p>这里以一个RRR机械手臂为例，分别介绍解析法中代数方法和几何方法计算IK问题。<br><img src="2.png" alt=""><br>首先我们计算出它的Transformation Matrix，如下：<br>$$<br>^0_3T=<br>\begin{bmatrix}<br>c_{123} &amp; -s_{123} &amp; 0 &amp; l_1c_1+l_2c_{12} \\<br>s_{123} &amp; c_{123} &amp; 0 &amp; l_1s_1+l_2s_{12} \\<br>0 &amp; 0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{bmatrix}<br>$$<br>我们的目标是得到如下的Transformation Matrix：<br>$$<br>^0_3T=<br>\begin{bmatrix}<br>c_{\phi} &amp; -s_{\phi} &amp; 0 &amp; x \\<br>s_{\phi} &amp; c_{\phi} &amp; 0 &amp; y \\<br>0 &amp; 0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{bmatrix}<br>$$</p><h3 id="几何法"><a href="#几何法" class="headerlink" title="几何法"></a>几何法</h3><p>对于这样一个简单的机械手臂来说，在一些特定的点仍然会有多重解，比如下图所示，手臂到达（x,y）点可以以蓝色折线的姿态，也可以以绿色折线的姿态。计算方式就是先运用余弦定理先计算出$\theta_2$，再利用余弦定理计算出中间角$\psi$，最后算出$\theta_1$和$\theta_3$。<br><img src="3.png" alt=""><br><img src="4.png" alt=""></p><h3 id="代数法"><a href="#代数法" class="headerlink" title="代数法"></a>代数法</h3><p><img src="5.png" alt=""><br><img src="6.png" alt=""><br><img src="7.png" alt=""></p><h2 id="Pieper’s-Solution"><a href="#Pieper’s-Solution" class="headerlink" title="Pieper’s Solution"></a>Pieper’s Solution</h2><p>Pieper准则就是说对于6自由度的机械手臂满足以下两个条件中的一个，就会有解析解。</p><ul><li>三个相邻关节轴相交于一点；</li><li>三个相邻关节轴相互平行。</li></ul><p>比如之前介绍的PUMA机械手臂，它的前三轴是用来产生移动的，后三轴是用来产生转动的，并且相交于一点，满足Pieper准则，$^0P_{6 org} = ^0P_{4 org}$<br><img src="8.png" alt=""><br>首先我们要根据最终的位置解出前三轴的角度。<br><img src="9.png" alt=""><br><img src="10.png" alt=""><br><img src="11.png" alt=""><br><img src="12.png" alt=""><br>在计算$\theta_3$时，用到了一种三角函数方程式求解的方法，如下图：<br><img src="13.png" alt=""><br>到这里，通过位置计算我们已经得到了$\theta_1，\theta_2，\theta_3$，接下来就要计算它的Orientation了。因为已经知道了$\theta_1，\theta_2，\theta_3$，所以就得到了$^0_3R$，从而推导出来$^3_6R=^0_3R^{-1}{^0_6R}$，最后我们就可以用Z—Y—Z Euler angle的方法解出$\theta_4，\theta_5，\theta_6$。但是这里要注意，我们需要把4 frame的Y轴转到5 frame的Z轴位置，这样的话5 frame对Z轴转动就相当于对4 frame的Y轴转动，然后因为4 frame的Z轴与6 frame重合，所以对6 frame的Z轴转动就相当与对4 frame的Z轴转动，但是要注意需要将4 frame转到与6 frame重合，这样就完成了Z—Y—Z的转动。这里用$\theta_4’，\theta_5’，\theta_6’$来说明用Z—Y—Z方法算出来的角度，而$\theta_4，\theta_5，\theta_6$是DH定义的角度，它们之间有一些差异。图解如下：<br><img src="14.png" alt=""><br><img src="15.png" alt=""></p><h3 id="举例：物件取放任务"><a href="#举例：物件取放任务" class="headerlink" title="举例：物件取放任务"></a>举例：物件取放任务</h3><p><img src="16.png" alt=""><br><img src="17.png" alt=""><br><img src="18.png" alt=""><br><img src="19.png" alt=""><br><img src="20.png" alt=""><br><img src="21.png" alt=""><br><img src="22.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向运动学 </tag>
            
            <tag> Inverse Kinematics </tag>
            
            <tag> Pieper Solution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂三--正向运动学</title>
      <link href="/2020/05/09/robot-arm-3/"/>
      <url>/2020/05/09/robot-arm-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在讨论正向运动学之前，我们先了解两个概念，一个是运动学（Kinematics），一个是动力学（Dynamics）。看起来名字都差不多，那么它们有什么差别呢？</p><ul><li>运动学（Kinematics）：讨论的是运动状态，未联系到产生运动的<strong>力</strong>。也就是位移，速度，加速度和时间之间的关系，比如$v=\frac{d}{dt}x$，$a=\frac{d}{dt}v$。</li><li>动力学（Dynamics）：讨论的是<strong>力</strong>和<strong>力矩</strong>是如何产生运动的。比如，$\sum F=ma$。</li></ul><p>在了解完运动学的概念后，那么什么是正向运动学呢？假设我们有一个简单的机械臂，如下图所示：<br><img src="1.png" alt=""><br>当我们知道了$l_1,l_2,l_3,\theta_1,\theta_2,\theta_3$时，通过简单的三角函数计算我们就可以一步一步的计算出机械臂末端点P所在的位置，那么这个就叫做正向运动学。反之，如果我们想要机械臂末端点P到达某个位置，那么我们就需要知道这个位置所对应的$\theta_1,\theta_2,\theta_3$，这个过程就是反向运动学（Inverse Kinematics），这个我们在下一讲介绍。</p><h1 id="机械手臂的几何描述"><a href="#机械手臂的几何描述" class="headerlink" title="机械手臂的几何描述"></a>机械手臂的几何描述</h1><p>机械手臂是由多个杆件（link）和关节（joint）所组成的。</p><ul><li>机械手臂的关节不但可以进行转动（revolute）还可以进行移动（prismatic），每个关节的运动都会沿着<strong>某特定axis</strong>进行。</li><li>机械手臂的杆件的作用就是将各个关节连接起来。</li></ul><p>为了计算出机械臂末端点所在空间的位置，我们需要一步一步的找到各个joint在空间中的位置，因此我们可以在每一个joint上建立坐标系，然后利用上一讲中介绍的Transformation Matrix来计算各个坐标系在空间中的位置，这样我们就间接的知道了各个joint的位置。</p><h2 id="第一步：建立frame"><a href="#第一步：建立frame" class="headerlink" title="第一步：建立frame"></a>第一步：建立frame</h2><p>在joint上建立坐标系的方式如下：</p><ul><li>首先要确定所有joint的$\hat Z$轴的方向，$\hat Z$轴就是这个joint转动或移动的方向。</li><li>然后再确定$\hat X_i$的方向，要沿着$a_i$的方向，$a_i$就是$\hat Z_i$和$\hat Z_{i+1}$之间的距离。但是，当$a_i=0$也就是说$\hat Z_i$和$\hat Z_{i+1}$相交时，$\hat X_i$要取和$\hat Z_i$和$\hat Z_{i+1}$两者都垂直的方向。</li><li>最后再确定$\hat Y_i$的方向，与$\hat X_i$和$\hat Z_i$两者垂直并遵循右手定则（拇指X，食指Y，中指Z）。<br><img src="2.png" alt=""></li></ul><h2 id="第二步：Denavit-Hartenberg表达法（Craig-version）"><a href="#第二步：Denavit-Hartenberg表达法（Craig-version）" class="headerlink" title="第二步：Denavit-Hartenberg表达法（Craig version）"></a>第二步：Denavit-Hartenberg表达法（Craig version）</h2><p>Denavit-Hartenberg表达法简称为DH表达法，它可以用4个参数来表达两个joint之间的关系。因此，如果将所有joint的关系整合起来形成一个表格，那么这个表格就可以用来表达完整的机械手臂，我们把这个表格叫做DH表，那4个参数分别为：$\alpha,a,d,\theta$。</p><ul><li>$\alpha_{i-1}$：是两个joint之间的夹角，计算方法是沿着$\hat X_{i-1}$的方向看过去，从$\hat Z_{i}$转到$\hat Z_{i-1}$的角度，顺时针为负，逆时针为正。</li><li>$a_{i-1}$：是两个joint之间的距离，计算方法是沿着$\hat X_{i-1}$的方向看过去，$\hat Z_{i-1}$到$\hat Z_i$的距离，可正可负。</li><li>$\theta_i$：对于转动的joint来说，这个值是变量。计算方法是沿着$\hat Z_{i}$的方向看过去，从$\hat X_{i}$转到$\hat X_{i-1}$的角度，顺时针为负，逆时针为正。</li><li>$d_i$：对于移动的joint来说，这个值是变量。计算方法是沿着$\hat Z_{i}$的方向看过去，从$\hat X_{i-1}$到$\hat X_{i}$的距离，可正可负。<br><img src="3.png" alt=""></li></ul><h2 id="第三步：计算每个joint之间的Transformation-Matrix"><a href="#第三步：计算每个joint之间的Transformation-Matrix" class="headerlink" title="第三步：计算每个joint之间的Transformation Matrix"></a>第三步：计算每个joint之间的Transformation Matrix</h2><p>接下来我们就要计算出每个joint之间的Transformation Matrix，计算方式如下：<br>$$<br>^{i-1}_iT=T_{\hat X_{i-1} }(\alpha_{i-1})T_{\hat X_R}(a_{i-1})T_{\hat Z_Q}(\theta_i)T_{\hat Z_P}(d_i) \\<br>= \begin{bmatrix}<br>c\theta_i &amp; -s\theta_i &amp; 0 &amp; a_{i-1}  \\<br>s\theta_ic\alpha_{i-1} &amp; c\theta_ic\alpha_{i-1} &amp; -s\alpha_{i-1} &amp; -s\alpha_{i-1}d_i  \\<br>s\theta_is\alpha_{i-1} &amp; c\theta_is\alpha_{i-1} &amp; c\alpha_{i-1} &amp; c\alpha_{i-1}d_i \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$$<br><img src="4.png" alt=""><br>计算的过程都是遵循上一讲所说的Eular Angles的情况，所以计算过程都是右乘。首先呢，先将i-1 frame沿着X轴转动到R frame，再沿着X轴移动到Q frame，接着再沿着Z轴转动到P frame，最后呢再沿着Z轴移动到i frame，就得到了我们最终想要的$^{i-1}_iT$。<br>同样的，它也可以进行多个Transformation Matrix连乘：<br>$$<br>^{i-1}_iT=^{0}_1T^{1}_2T^{2}_3T…^{n-2}_{n-1}T^{n-1}_nT<br>$$</p><blockquote><p>Note: 通过这种方式我们就可以得到任意joint相对于基坐标（0 frame）的Transformation Matrix，从而得到任意joint相对于基坐标的位置。</p></blockquote><h3 id="举例-PUMA-560-1"><a href="#举例-PUMA-560-1" class="headerlink" title="举例 PUMA 560 -1"></a>举例 PUMA 560 -1</h3><h4 id="建立frame"><a href="#建立frame" class="headerlink" title="建立frame"></a>建立frame</h4><p>PUMA 560-1机械手臂坐标系的建立如下图所示，当然这并不是唯一的方法，X轴，Y轴，Z轴的方向都可以和下图所示的方法相反，只不过不同的方法会建立不同的DH表。<br><img src="5.png" alt=""></p><blockquote><p>Note: </p><ol><li>0 frame是基坐标，可以定在任意位置。</li><li>$\hat Z_1$与$\hat Z_2$相交，所以$\hat X_1$的方向要垂直与$\hat Z_1$和$\hat Z_2$</li></ol></blockquote><h4 id="建立DH表"><a href="#建立DH表" class="headerlink" title="建立DH表"></a>建立DH表</h4><p>DH表如下图所示。因为我们的手臂有6个DOF，所以i的取值就从1-6。1代表1 frame，2代表2 frame，以此类推。首先看第一行，因为0 frame和1 frame完全重合，所以$\alpha_0, a_0, d_1$都是0，唯一可能会变的就是$\theta_1$这个变量。第二行中，沿着$\hat X_{1}$的方向看过去，从$\hat Z_{2}$转到$\hat Z_{1}$的角度为顺时针$90^\circ$，所以$\alpha_1=-90^\circ$。$\hat Z_{1}$到$\hat Z_{2}$的距离为0，所以$a_1=0$，$\hat X_{1}$到$\hat X_{2}$的距离为0，所以$d_1=0$，$\theta_2$同样是变量。以此类推就可以得到整个DH表。<br><img src="6.png" alt=""></p><h4 id="计算Transformation-Matrix"><a href="#计算Transformation-Matrix" class="headerlink" title="计算Transformation Matrix"></a>计算Transformation Matrix</h4><p>计算的方式就是将DH表里的参数带入之前介绍的计算Transformation Matrix的公式里，结果如下图：<br><img src="7.png" alt=""><br><img src="8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正向运动学 </tag>
            
            <tag> Forward Kinematics </tag>
            
            <tag> DH表达法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂二--旋转矩阵和变换矩阵的计算</title>
      <link href="/2020/05/05/robot-arm-2/"/>
      <url>/2020/05/05/robot-arm-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="旋转矩阵与转角的关系"><a href="#旋转矩阵与转角的关系" class="headerlink" title="旋转矩阵与转角的关系"></a>旋转矩阵与转角的关系</h1><p>上一讲中我们介绍了质点沿着某一坐标轴旋转的旋转矩阵的计算方法，但是在更普遍的情况下，质点的旋转并不是沿着某一坐标轴，而可能是空间中的任意轴。所以这一讲我们将介绍如何通过拆解为沿坐标轴旋转的方式来计算任意旋转矩阵。</p><p>拆解的方式有两种：</p><ol><li>Fixed angles – 根据一个固定不动的坐标系进行旋转</li><li>Euler angles – 对转动后的坐标系再此进行旋转</li></ol><h2 id="Fixed-angles"><a href="#Fixed-angles" class="headerlink" title="Fixed angles"></a>Fixed angles</h2><p>如下图所示，A frame是固定不变的坐标系，我们先沿着$\hat{X}$轴旋转$\gamma$角度，再沿着$\hat{Y}$轴旋转$\beta$角度，最后沿着$\hat{Z}$轴旋转$\alpha$角度得到了B frame。<br><img src="1.png" alt=""><br>旋转矩阵的计算方式如下：<br>$$<br>\begin{aligned}<br>&amp;^A_BR_{XYZ}(\gamma,\beta,\alpha) =<br>R_Z(\alpha)R_Y(\beta)R_X(\gamma) \\<br>&amp;=    \begin{bmatrix}<br>    c\alpha c\beta &amp; c\alpha s\beta s\gamma - s\alpha c\gamma &amp; c\alpha s\beta c\gamma + s\alpha s\gamma \\<br>    s\alpha c\beta &amp; s\alpha s\beta s\gamma + c\alpha c\gamma &amp; s\alpha s\beta c\gamma - c\alpha s\gamma \\<br>    -s\beta &amp; c\beta s\gamma &amp; c\beta c\gamma<br>    \end{bmatrix} \\<br>&amp;= \begin{bmatrix}<br>r_{11} &amp; r_{12} &amp; r_{13}  \\<br>r_{21} &amp; r_{22} &amp; r_{23}  \\<br>r_{31} &amp; r_{32} &amp; r_{33}  \\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><blockquote><p>Note: Fixed angles下，旋转矩阵采用的是左乘的方式计算。</p></blockquote><p>当我们已知旋转矩阵R时，怎么反推出来旋转的角度呢？根据$r_{31}$元素的值我们可以直接算出$\beta$角，然而$\beta$角的取值会有如下三种情况：<br>如果$\beta \neq \pm90^\circ$：<br>$$<br>\begin{aligned}<br>\beta &amp;= Atan2(-r_{31}, \sqrt{r_{11} ^2 + r_{21} ^2}) \\<br>\alpha &amp;= Atan2(r_{21}/c\beta, r_{11}/c\beta) \\<br>\gamma &amp;= Atan2(r_{32}/c\beta, r_{33}/c\beta)<br>\end{aligned}<br>$$<br>如果$\beta = 90^\circ$：<br>$$<br>\begin{aligned}<br>&amp;\alpha = 0^\circ \\<br>&amp;\gamma = Atan2(r_{12},r_{22})<br>\end{aligned}<br>$$<br>如果$\beta = -90^\circ$：<br>$$<br>\begin{aligned}<br>&amp;\alpha = 0^\circ \\<br>&amp;\gamma = -Atan2(r_{12},r_{22})<br>\end{aligned}<br>$$</p><blockquote><p>Note: 当$\beta \neq \pm90^\circ$时，就发生了欧拉旋转的万向锁问题。这个问题在欧拉旋转中总是会发生，无论是Fixed angles还是Eular angls，无论是X-Y-Z，Y-X-Z，Z-Y-X等等所有旋转都会发生。根据图示可以更好的理解，当第二次旋转为$\pm90^\circ$时，第三次要旋转的轴一定就是第一次旋转的轴，这样的话就会导致损失一个自由度，所以直接给第一次旋转的角度$\alpha$赋值为0，放弃这个自由度，但是计算结果是正确的。</p></blockquote><h2 id="Euler-angles（Z-Y-X）"><a href="#Euler-angles（Z-Y-X）" class="headerlink" title="Euler angles（Z-Y-X）"></a>Euler angles（Z-Y-X）</h2><p>如下图所示，A frame是我们即将要旋转的坐标系，首先我们先沿着$\hat{Z}$轴旋转$\alpha$角度，再沿着旋转之后的坐标系的$\hat{Y}$轴旋转$\beta$角度，最后再沿着$\hat{X}$轴旋转$\gamma$角度得到了B frame。<br><img src="2.png" alt=""><br>旋转矩阵的计算方式如下：<br>$$<br>\begin{aligned}<br>&amp;^A_BR_{ZYX}(\alpha,\beta,\gamma) =<br>R_Z(\alpha)R_Y(\beta)R_X(\gamma) \\<br>&amp;=    \begin{bmatrix}<br>    c\alpha c\beta &amp; c\alpha s\beta s\gamma - s\alpha c\gamma &amp; c\alpha s\beta c\gamma + s\alpha s\gamma \\<br>    s\alpha c\beta &amp; s\alpha s\beta s\gamma + c\alpha c\gamma &amp; s\alpha s\beta c\gamma - c\alpha s\gamma \\<br>    -s\beta &amp; c\beta s\gamma &amp; c\beta c\gamma<br>    \end{bmatrix} \\<br>&amp;= \begin{bmatrix}<br>r_{11} &amp; r_{12} &amp; r_{13}  \\<br>r_{21} &amp; r_{22} &amp; r_{23}  \\<br>r_{31} &amp; r_{32} &amp; r_{33}  \\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><blockquote><p>Note: Euler angles下，旋转矩阵采用的是右乘的方式计算。</p></blockquote><p>我们发现与X-Y-Z fixed angle得到同样的旋转矩阵，所以Fix angle下以X-Y-Z来转就等于Eular angle下以Z-Y-X来转。因为旋转矩阵是一样的，那么反推旋转角度的计算方式和Fixed angle也是一样的。</p><h2 id="Euler-angles（Z-Y-Z）"><a href="#Euler-angles（Z-Y-Z）" class="headerlink" title="Euler angles（Z-Y-Z）"></a>Euler angles（Z-Y-Z）</h2><p>Euler angles还有一种旋转方式就是Z-Y-Z，即我们先沿着$\hat{Z}$轴旋转$\alpha$角度，再沿着旋转之后的坐标系的$\hat{Y}$轴旋转$\beta$角度，最后再沿着$\hat{Z}$轴旋转$\gamma$角度。如下图所示：<br><img src="3.png" alt=""><br>旋转矩阵的计算方式如下：<br>$$<br>\begin{aligned}<br>&amp;^A_BR_{ZYZ}(\alpha,\beta,\gamma) =<br>R_Z(\alpha)R_Y(\beta)R_Z(\gamma) \\<br>&amp;=    \begin{bmatrix}<br>    c\alpha c\beta c\gamma - s\alpha s\gamma &amp; -c\alpha c\beta s\gamma - s\alpha c\gamma &amp; c\alpha s\beta \\<br>    s\alpha c\beta c\gamma + c\alpha s\gamma &amp; -s\alpha c\beta s\gamma + c\alpha c\gamma &amp; s\alpha s\beta \\<br>    -s\beta c\gamma &amp; s\beta s\gamma &amp; c\beta<br>    \end{bmatrix} \\<br>&amp;= \begin{bmatrix}<br>r_{11} &amp; r_{12} &amp; r_{13}  \\<br>r_{21} &amp; r_{22} &amp; r_{23}  \\<br>r_{31} &amp; r_{32} &amp; r_{33}  \\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><blockquote><p>Note: Euler angles下，旋转矩阵采用的是右乘的方式计算。</p></blockquote><p>要计算旋转的角度，我们首先根据$r_{33}$元素的值算出$\beta$角，然而$\beta$角的取值依然会有如下三种情况：<br>如果$\beta \neq 0^\circ or 180^\circ$：<br>$$<br>\begin{aligned}<br>\beta &amp;= Atan2(\sqrt{r_{31} ^2 + r_{32} ^2}, r_{33} ) \\<br>\alpha &amp;= Atan2(r_{23}/s\beta, r_{13}/s\beta) \\<br>\gamma &amp;= Atan2(r_{32}/s\beta, -r_{31}/s\beta)<br>\end{aligned}<br>$$<br>如果$\beta = 0^\circ$：<br>$$<br>\begin{aligned}<br>&amp;\alpha = 0^\circ \\<br>&amp;\gamma = Atan2(-r_{12},r_{11})<br>\end{aligned}<br>$$<br>如果$\beta = 180^\circ$：<br>$$<br>\begin{aligned}<br>&amp;\alpha = 0^\circ \\<br>&amp;\gamma = -Atan2(r_{12},-r_{11})<br>\end{aligned}<br>$$</p><h1 id="Transformation-matrix"><a href="#Transformation-matrix" class="headerlink" title="Transformation matrix"></a>Transformation matrix</h1><p>因为刚体在空间中的状态有移动$\vec{P}$和转动$R$两种，为了方便计算我们需要将这两种状态整合到一个矩阵里计算，因此我们引入了变换矩阵：<br>$$<br>^A_BT=<br> \left[<br>\begin{array}{ccc|c}<br>  &amp;^A_BR_{3\times3}&amp;&amp;^AP_{B org 3\times1}\\<br>\hline<br>  0&amp;0&amp;0&amp;1<br>\end{array}<br>\right] _{4\times4}<br>$$</p><h2 id="Transformation-matrix的应用"><a href="#Transformation-matrix的应用" class="headerlink" title="Transformation matrix的应用"></a>Transformation matrix的应用</h2><p>Transformation matrix的应用有两种情况：一种是已知某个质点在一个坐标系的位置，通过两个坐标系的变换矩阵来计算这个质点在另一个坐标系的位置；另一种是在同一个坐标系下，计算某质点经过移动和旋转后的新的坐标。</p><p>在第一种情况下，例如，已知P点在B frame下的坐标，以及B frame对A frame的Transformation matrix，那么P点在A frame的坐标就是：<br>$$<br>\begin{bmatrix}<br>^AP \\<br>1<br>\end{bmatrix} =<br>\begin{bmatrix}<br>  &amp;^A_BR&amp;&amp;^AP \\<br>  0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>^BP \\<br>1<br>\end{bmatrix} =<br>\begin{bmatrix}<br>^A_BR^BP+^AP_{Borg} \\<br>1<br>\end{bmatrix}<br>$$</p><blockquote><p>Note: Tranforamtion Matrix是可以连续操作的:$^A_BT=^A_CT^C_DT^D_BT$<br>这样的话，我们只要是知道任何坐标系之间的T，就可以知道任意点在不同坐标系下的坐标。</p></blockquote><p>在第二种情况下，如果质点是先转动再移动的话，那么计算方式和第一种情况相同，因为我们看最终P点在A frame下的表达式：$^AP_2 = R^AP_1+P$，P点先左乘R进行了转动，才加上偏移量进行了移动，只不过这里的P和R都是相对于自身坐标系来说的。如果是先移动再转动的话，表达式应该是这样：$^AP_2 = R(^AP_1+P)$，结果完全不同。</p><h2 id="Transformation-matrix的运算"><a href="#Transformation-matrix的运算" class="headerlink" title="Transformation matrix的运算"></a>Transformation matrix的运算</h2><ol><li>连续运算<br>$$<br>^AP=^A_BT^BP=^A_BT(^B_CT^CP)=^A_BT^B_CT^CP<br>$$</li><li>反矩阵（计算过程省略）</li></ol><p>$$<br>^A_BT^{-1}=<br>\begin{bmatrix}<br>  &amp;^A_BR^T&amp;&amp;-^A_BR^T{^AP_{Borg} } \\<br>  0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p><ol start="3"><li><p>连续运算，求未知T<br>已知$^U_DT=^U_AT^A_DT=^U_BT^B_CT^C_DT$，如图：<img src="4.png" alt=""><br>如果$^C_DT$不知道，那么<br>$$<br>^C_DT=(^U_BT^B_CT)^{-1}{^U_AT^A_DT}<br>$$</p></li><li><p>连续运算法则<br>假设有两个frame，A和B，然而B frame需要经过$T_1$，$T_2$，$T_3$三次按照转轴旋转和移动才能与A重合。那么，如果B frame是按照A frame的转轴旋转，$^A_BT=T_3T_2T_1I$，要按照左乘的规则，这就是前面讲的fixed angles的情况；如果B frame是按照B frame自身的转轴旋转，$^A_BT=IT_1T_2T_3$，要按照右乘的规则，这就是前面讲的Euler angles的情况。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rotation Matrix </tag>
            
            <tag> Transformation Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂一--刚体的运动状态</title>
      <link href="/2020/05/04/robot-arm-1/"/>
      <url>/2020/05/04/robot-arm-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>刚体在空间中的运动方式有两种，一种是移动，一种是转动，它们各有3个DOF。对于移动来说，它可以沿着$\hat{X}$轴，$\hat{Y}$轴和$\hat{Z}$轴移动， 同样的，转动也可以沿着$\hat{X}$轴，$\hat{Y}$轴和$\hat{Z}$轴进行转动。为了描述刚体在空间中的运动状态，我们通常会在它的质心位置建立一个坐标系（frame）, 通过得到这个坐标系与世界坐标系之间的关系，我们可以知道这个刚体在空间中的姿态。</p><h1 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h1><p>刚体的移动可以用向量$\vec{P}$来描述，它即明确了移动的方向，又说明了移动的大小。如下图：<br><img src="1.png" alt=""><br>因为位置是相对的，为了表明$\vec{P}$是以A frame为基坐标上B frame的位置，我们通常写为$^AP_B org$，其中org指的是B frame的原点，即刚体的质心。</p><h1 id="转动"><a href="#转动" class="headerlink" title="转动"></a>转动</h1><p>刚体的转动需要用三个向量来描述，因此我们将它写成矩阵的形式，并将这个矩阵称之为旋转矩阵（Rotation Matrix），用$^A_BR$来表示（B frame相对于A frame）。$^A_BR$的三个columns其实是B frame的$\hat{X}$轴，$\hat{Y}$轴以及$\hat{Z}$轴方向的单位向量在A frame下的投影，因此旋转矩阵的三个cloumns的长度都为1。如图：<br><img src="2.png" alt=""></p><h2 id="旋转矩阵的特性"><a href="#旋转矩阵的特性" class="headerlink" title="旋转矩阵的特性"></a>旋转矩阵的特性</h2><p>旋转矩阵有如下特性：</p><ul><li>$^A_BR$=$^B_AR^T\to$ B对A的旋转矩阵就相当于A对B的旋转矩阵的转置</li><li>$^A_BR^T$=$^A_BR^{-1}$=$^B_AR\to$ 旋转矩阵的逆矩阵等于它的转置。这个特性非常有用，因为逆矩阵的计算往往需要很大的计算量，有了这个特性，我们就可以很容易的得到旋转矩阵的逆矩阵。</li></ul><h2 id="旋转矩阵的使用"><a href="#旋转矩阵的使用" class="headerlink" title="旋转矩阵的使用"></a>旋转矩阵的使用</h2><p>旋转矩阵除了可以描述B frame相对于A frame的姿态以外，也可以计算向量在不同frame下的坐标。比如有一个在B frame下的向量$^BP$，那么它在A frame下的坐标就可以这样得到: $^AP$=$^A_BR$$^BP$<br>以上的应用都是在已知两个frame的旋转矩阵下进行的，当有一个向量要在同一个frame下沿某个轴转动某个角度时，我们就需要计算出旋转矩阵，计算方式如下：<br>$$<br>R_{ {\hat{X} }_A}(\theta)=<br>    \begin{bmatrix}<br>    1 &amp; 0 &amp; 0 \\<br>    0 &amp; cos\theta &amp; -sin\theta \\<br>    0 &amp; sin\theta &amp; cos\theta<br>    \end{bmatrix}<br>$$$$<br>R_{ {\hat{Y} }_A}(\theta) =<br>    \begin{bmatrix}<br>    cos\theta &amp; 0 &amp; sin\theta \\<br>    0 &amp; 1 &amp; 0 \\<br>    -sin\theta &amp; 0 &amp; cos\theta<br>    \end{bmatrix}<br>$$$$<br>R_{ {\hat{Z} }_A}(\theta) =<br>    \begin{bmatrix}<br>    cos\theta &amp; -sin\theta &amp; 0 \\<br>    sin\theta &amp; cos\theta &amp; 0 \\<br>    0 &amp; 0 &amp; 1<br>    \end{bmatrix}<br>$$<br>例如有点$^AP$对$\hat{X}_A$轴转动$\theta$角度后得到了点$^AP’$,那么点$^AP’$的坐标就是：$$<br>    ^AP’=R_{ {\hat{X} }_A}(\theta)^AP<br>$$注意：点$^AP’$的坐标是基于{A}的，而不是旋转后的坐标{A’}的。</p>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刚体运动 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
