<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机械手臂七--轨迹规划实例</title>
      <link href="/2020/05/14/robot-arm-7/"/>
      <url>/2020/05/14/robot-arm-7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="任务概述"><a href="#任务概述" class="headerlink" title="任务概述"></a>任务概述</h1><p>机械手臂需要夹住放在桌子上的杯子，然后将杯子挂到墙上的杯架，位置参数以及手臂的DH参数如下图：<br><img src="1.png" alt=""><br><img src="2.png" alt=""></p><h1 id="条件设定"><a href="#条件设定" class="headerlink" title="条件设定"></a>条件设定</h1><ol><li>我们需要规划手臂将杯子从桌子上拿起然后放到杯架上的整个轨迹。为了让轨迹变得顺滑，我们可以先让手臂拿起杯子一小段距离到$f_{c_1}$，然后到达杯架前，调整到适当姿态，然后将杯子平移到杯架上，如下图所示：<br><img src="3.png" alt=""></li><li>我们要定义杯子在各点（$P_{0-f}$）的时间、坐标位置以及姿态。<br><img src="4.png" alt=""><br><img src="5.png" alt=""></li><li>我们就可以求出杯子在各点处相对于世界坐标的Transformation Matrix （$^0_CT$）<br><img src="6.png" alt=""></li><li>再推导出手臂末端点在各点处相对于世界坐标的Transformation Matrix （$^0_6T$）<br><img src="7.png" alt=""></li><li>从$^0_6T$得知$^0P_{6org}$在各点的位置和姿态。<br><img src="8.png" alt=""></li></ol><h1 id="以linear-function-with-parabolic-blends在Cartesian-space下规划轨迹"><a href="#以linear-function-with-parabolic-blends在Cartesian-space下规划轨迹" class="headerlink" title="以linear function with parabolic blends在Cartesian-space下规划轨迹"></a>以linear function with parabolic blends在Cartesian-space下规划轨迹</h1><ol><li>求出$^0P_{6org}$在各DOF（$X,Y,Z,\Phi_X,\Phi_Y,\Phi_Z$）每段的速度和加速度<br><img src="9.png" alt=""></li><li>建立并绘出各DOF在每个时间区段的轨迹<br><img src="10.png" alt=""></li><li>此时轨迹规划已经完成，接下来就要用IK计算出轨迹上所有设定点以及轨迹内插点的六轴转角（计算量很大）。以第二个via point为例：<br><img src="11.png" alt=""><br><img src="12.png" alt=""><br><img src="13.png" alt=""><br><img src="14.png" alt=""><br><img src="15.png" alt=""> </li><li>将解出的轨迹设定点以及轨迹内插点的六轴转角对各自的时间进行画图：<br><img src="16.png" alt=""> </li><li>将转角带入FK，画出杯子的坐标及姿态，已确认轨迹规划的正确性，同样以第二个via point为例：<br><img src="17.png" alt=""></li></ol><h1 id="以linear-function-with-parabolic-blends在joint-space下规划轨迹"><a href="#以linear-function-with-parabolic-blends在joint-space下规划轨迹" class="headerlink" title="以linear function with parabolic blends在joint-space下规划轨迹"></a>以linear function with parabolic blends在joint-space下规划轨迹</h1><ol><li>以IK先计算出各点的六轴转角<br><img src="18.png" alt=""></li><li>求出各轴（$\theta_1-\theta_6$）在每个时段的速度及加速度<br><img src="19.png" alt=""></li><li>建立各轴在每个时段的轨迹<br><img src="20.png" alt=""></li><li>以FK画出杯子对事件的轨迹，确认轨迹有通过设定点。<br><img src="21.png" alt=""></li><li>在Cartensian-space下和在joint-space下轨迹比较。<br><img src="22.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械手臂轨迹规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂六--线性与二次方程搭配的轨迹规划曲线</title>
      <link href="/2020/05/13/robot-arm-6/"/>
      <url>/2020/05/13/robot-arm-6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>上一讲中我们介绍了一种用三次多项式的方式来规划轨迹曲线的方式，但是在很多实际任务中我们需要用到直线轨迹。但是如果单纯的使用直线轨迹，那么在两段之间的中间点处速度是不连续的，为了解决这个问题，我们把直线两端修改为二次方程式，从而让速度变得平滑，如下图：<br><img src="1.png" alt=""></p><h1 id="规划方式"><a href="#规划方式" class="headerlink" title="规划方式"></a>规划方式</h1><p>规划的方式分为两段，直线段和二次多项式段：</p><ul><li>Linear段，是匀速的：<br>$$<br>\dot \theta=\frac{\theta_h-\theta_b}{t_h-t_b}=\dot \theta_{t_b}<br>$$</li><li>Parabolic段，是等加速的：<br>$$<br>\begin{aligned}<br>&amp;\theta(t)=\theta_0+\dot \theta_0t+\frac{1}{2}\color{red}{\ddot \theta}t^2 （这个是等加速度的位移公式）\\<br>&amp;\dot \theta(t)=\dot \theta_0+\color{red}{\ddot \theta}t \\<br>&amp;\dot \theta(t_b)=\color{red}{\ddot \theta}t_b（assume \space \dot \theta_0=0） \\<br>\end{aligned}<br>$$<br><img src="2.png" alt=""><br>因为直线段和二次多项式段的交界处的速度需要一样，所以可以得到如下结论：<br><img src="3.png" alt=""></li></ul><h2 id="对加速度-ddot-theta-的讨论"><a href="#对加速度-ddot-theta-的讨论" class="headerlink" title="对加速度$\ddot \theta$的讨论"></a>对加速度$\ddot \theta$的讨论</h2><p><img src="4.png" alt=""></p><h2 id="三种方式的比较"><a href="#三种方式的比较" class="headerlink" title="三种方式的比较"></a>三种方式的比较</h2><p><img src="5.png" alt=""></p><h1 id="多段Linear-Function-with-Parabolic-Blends"><a href="#多段Linear-Function-with-Parabolic-Blends" class="headerlink" title="多段Linear Function with Parabolic Blends"></a>多段Linear Function with Parabolic Blends</h1><p>假设，有一个路径规划，其中有n个中间点，然后用Linear Function with Parabolic Blends的方法将各个点串起来，但是实际的轨迹并没有经过中间点（黑色实线），如下图所示：<br><img src="6.png" alt=""></p><ul><li>轨迹中间线段$[\theta_i \space \theta_{i+1}]$的计算方式：<br><img src="7.png" alt=""></li><li>轨迹第一段的计算方法：<br>前面我们说过实际的轨迹并没有经过中间点，但是起始位置是必须要经过的，所以我们不能用计算中间线段的方式来计算起始点。这里假设起始位置速度为0，然后我们可以在$\theta_0$的后面插入一个假设的中间点$\theta_1$，并且它的位置是二次多项式所需时间$t_1$的一半（$t_{\theta_1}=\frac{1}{2}t_1$）。然后用以下方式计算：<br><img src="8.png" alt=""></li><li>轨迹最后一段的计算方法：<br>最后一段和第一段一样，假设最后速度为0，在$\theta_f$点前插入一个假设的中间点$\theta_n$，并且它的位置是二次多项式所需时间$t_n$的一半（$t_{\theta_n}=\frac{1}{2}t_n$）。然后用以下方式计算：<br><img src="9.png" alt=""></li></ul><h2 id="举例：一个RRR手臂"><a href="#举例：一个RRR手臂" class="headerlink" title="举例：一个RRR手臂"></a>举例：一个RRR手臂</h2><p><img src="10.png" alt=""><br><img src="11.png" alt=""><br><img src="12.png" alt=""><br><img src="13.png" alt=""></p><h1 id="多段Linear-Function-with-Parabolic-Blends的讨论"><a href="#多段Linear-Function-with-Parabolic-Blends的讨论" class="headerlink" title="多段Linear Function with Parabolic Blends的讨论"></a>多段Linear Function with Parabolic Blends的讨论</h1><ol><li>在真实系统中可以达到的加速度$\ddot \theta$取决于很多因素：<ul><li>电机的规格</li><li>手臂的姿态：手臂在不同状态下，各个joint所需要承受的torque不同。</li><li>手臂的动作状态：手臂在不同运行状态下，各个joint所需要承受的惯性力不同。</li></ul></li><li>路径规划没有通过中间点的解决方法：在原本的via points两边插入pseudo via points（橘色的点），让原本的via points落在linear段上，这样就会通过，如下图：<br><img src="14.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械手臂线性轨迹规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂五--轨迹规划</title>
      <link href="/2020/05/13/robot-arm-5/"/>
      <url>/2020/05/13/robot-arm-5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>机械手臂的轨迹规划就是说当手臂执行某一个操作时，比如说，从一个位置取某一物件然后移动到另一个位置，这段运动轨迹就需要我们来规划，规划的内容就包括位置、速度以及加速度随时间的变化。通常我们理想的轨迹都是平滑的曲线，其中包括起始点{$T_{initial}$}，很多的中间点{$T_{t_i}$}以及终点{$T_{final}$}。如果轨迹变化很大的话，那么在变化的那个点就需要手臂有很大的torque来改变运动状态，有时手臂可能做不到，而且会让整个运动过程看起来不流畅。<br><img src="1.png" alt=""></p><h1 id="轨迹规划"><a href="#轨迹规划" class="headerlink" title="轨迹规划"></a>轨迹规划</h1><p>轨迹的规划方式有两种，一种是在joint-space下进行，一种是在Cartesian-space下进行。接下来将分别介绍两种方法，以及它们的优缺点。</p><h2 id="Joint-space下的轨迹规划"><a href="#Joint-space下的轨迹规划" class="headerlink" title="Joint-space下的轨迹规划"></a>Joint-space下的轨迹规划</h2><p>在Joint-space下规划轨迹的方法如下：</p><ol><li>定义这段轨迹在空间中的起始点{$T_{initial}$}，中间点{$T_{t_i}$}以及终点{$T_{final}$}。</li><li>计算这些点的IK，得到在每个时间点$t_i$，手臂的每个joint所对应的角度。</li><li>对每一个joint都在其自己的角度坐标系下规划一条平滑的曲线。</li><li>计算FK，检查手臂末端点在Cartesian-space下轨迹的可行性（可能会碰到障碍物）。</li></ol><p>具体过程如下图：<br><img src="2.png" alt=""></p><blockquote><p>Note：<br>优点：计算量小，只需要计算起始点、中间点和终点的IK。<br>缺点：在空间中的运动轨迹不直观。</p></blockquote><h2 id="Cartesian-space下的轨迹规划"><a href="#Cartesian-space下的轨迹规划" class="headerlink" title="Cartesian-space下的轨迹规划"></a>Cartesian-space下的轨迹规划</h2><p>在Cartesian-space下规划轨迹的方法如下：</p><ol><li>定义这段轨迹在空间中的起始点{$T_{initial}$}，中间点{$T_{t_i}$}以及终点{$T_{final}$}。</li><li>对每一个手臂末端点的状态参数（$x,y,z,\theta_x,\theta_y,\theta_z$）规划一条平滑的曲线。</li><li>将规划好的手臂末端点状态的轨迹点计算IK，转换到joint-space下。</li><li>检查joint在joint-space下轨迹的可行性（有的joint的转动角度有限制或者角加速度太大手臂做不到）。</li></ol><p>具体过程如下图：<br><img src="3.png" alt=""></p><blockquote><p>Note：<br>优点：在空间中的运动轨迹比较直观。<br>缺点：计算量大，需要计算整个轨迹点的IK。</p></blockquote><h1 id="轨迹规划曲线—三次多项式"><a href="#轨迹规划曲线—三次多项式" class="headerlink" title="轨迹规划曲线—三次多项式"></a>轨迹规划曲线—三次多项式</h1><p>轨迹规划中平滑的曲线需要写成函数的形式，这样我们才能得到不同时刻的值。在这里我们用三次多项式（Cubic Polynomials）的形式来规划路径，也就是说，每两个中间点之间可以写成三次多项式的函数形式，不同轨迹区段[$t_i$ $t_{i+1}$]是不同的三次多项式。然后为了使整体的路径规划平滑，我们需要给相邻的两个区段增加限制条件，包括位置和速度（$\theta(t_i)$，$\theta(t_{i+1})$，$\dot\theta(t_i)$，$\dot\theta(t_{i+1})$）。<br><img src="4.png" alt=""></p><h2 id="解三次多项式"><a href="#解三次多项式" class="headerlink" title="解三次多项式"></a>解三次多项式</h2><ol><li><p>三次多项式的通式：<br>$$<br>\theta(\tilde t)=a_0+a_1\tilde t+a_2\tilde t^2+a_3\tilde t^3, 4\space unknown\space para: a_j \space _{j=0…3}<br>$$<br>每一个区段[$t_i$ $t_{i+1}$]都有一个这样的三次多项式，只不过每段的参数不同。</p></li><li><p>$\tilde t$的取值：<br>对每一个区段：$t\in[t_i,t_{i+1}]$<br>$\tilde t=t-t_i$，所以$\tilde t|_{t=t_i}=0$</p></li><li><p>增加边界条件：<br>首先当$t=t_i$和$t=t_{i+1}$时，这个三次多项式函数需要落在$\theta_i$和$\theta_{i+1}$上，所以有：<br>$$<br>\begin{aligned}<br>&amp;\theta(\tilde t|_{t=t_i})=\theta_i=\color{red}{a_0} \\<br>&amp;\theta(\tilde t|_{t=t_{i+1} })=\theta_{i+1}=a_0+a_1\Delta t+a_2\Delta t^2+a_3\Delta t^3 \\<br>\end{aligned}<br>$$<br>然后这个三次多项式函数在$t=t_i$和$t=t_{i+1}$时的速度也需要我们来设计，所以有：<br>$$<br>\begin{aligned}<br>&amp;\dot \theta(\tilde t|_{t=t_i})=\dot \theta_i=\color{red}{a_1} \\<br>&amp;\dot \theta(\tilde t|_{t=t_{i+1} })=\dot \theta_{i+1}=a_1+2a_2\Delta t+3a_4\Delta t^2 \\<br>\end{aligned}<br>$$</p></li><li><p>联立上面4个方程式最后解出：<br>$$<br>\begin{aligned}<br>&amp;\color{red}{a_2} = \frac{3}{\Delta t^2}(\theta_{i+1}-\theta_i)-\frac{2}{\Delta t}\dot \theta_i-\frac{1}{\Delta t}\dot \theta_{i+1} \\<br>&amp;\color{red}{a_3} = -\frac{2}{\Delta t^3}(\theta_{i+1}-\theta_i)+\frac{1}{\Delta t^2}(\dot \theta_{i+1}+\dot \theta_i)<br>\end{aligned}<br>$$</p></li><li><p>用Matrix的方式计算：<br><img src="5.png" alt=""></p></li></ol><h2 id="多段三次多项式"><a href="#多段三次多项式" class="headerlink" title="多段三次多项式"></a>多段三次多项式</h2><p>在上面的计算中，我们需要设计在边界的速度条件$\dot \theta_i$和$\dot \theta_{i+1}$，那么我们该如何设计呢？</p><ol><li>自己定义。不建议用这个方法，这样会使我们整个路径规划变得很复杂。</li><li>自动生成：<br>如果$\dot \theta_i$在$t_i$前后变号，那么$\dot \theta_i$就取0；<br>如果$\dot \theta_i$在$t_i$前后同号，那么$\dot \theta_i$就取前后两段速度的平均数；<br><img src="6.png" alt=""></li></ol><h3 id="举例：有一个中间点的路径规划"><a href="#举例：有一个中间点的路径规划" class="headerlink" title="举例：有一个中间点的路径规划"></a>举例：有一个中间点的路径规划</h3><p><img src="7.png" alt=""><br><img src="8.png" alt=""><br><img src="9.png" alt=""><br><img src="10.png" alt=""></p><h2 id="多段三次多项式通解"><a href="#多段三次多项式通解" class="headerlink" title="多段三次多项式通解"></a>多段三次多项式通解</h2><p>假设一共有N+1个点，其中有1个初始点，N-1个中间点和1个终点。那么我们一共就有N个三次多项式，每个三次多项式有4个未知参数，所以一共有4N个未知量。为了求解这4N个未知量，我们就需要4N个限制条件：</p><ul><li>每一段会有两个位置条件，所以一共有2N个位置条件；</li><li>每一个中间点会有一个速度条件和一个加速度条件，所以一共有2（N-1）个速度和加速度条件；</li><li>目前为止一共有4N-2个条件，那么最后两个条件我们可以限制起始点和终点点的速度或者是加速度，这样就有4N个条件了。</li></ul><h3 id="举例：一个RRR的机械手臂"><a href="#举例：一个RRR的机械手臂" class="headerlink" title="举例：一个RRR的机械手臂"></a>举例：一个RRR的机械手臂</h3><p>方法一：用三次多项式在Cartesian-space下规划路径：<br><img src="11.png" alt=""><br><img src="12.png" alt=""><br><img src="13.png" alt=""><br><img src="14.png" alt=""><br>方法二：用三次多项式在joint-space下规划路径：<br><img src="15.png" alt=""><br><img src="16.png" alt=""><br><img src="17.png" alt=""></p><h2 id="高阶多项式"><a href="#高阶多项式" class="headerlink" title="高阶多项式"></a>高阶多项式</h2><p>如果我们不但要规划位置和速度，还要规划加速度的话，我们就需要用到五次多项式，而不是四次多项式。因为位置、速度和加速度分别会产生2个条件，一共有6个条件，五次多项式有6个未知数。<br><img src="18.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械手臂轨迹规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂四--逆向运动学</title>
      <link href="/2020/05/11/robot-arm-4/"/>
      <url>/2020/05/11/robot-arm-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>上一讲介绍了正向运动学（Forward Kinematics），它的计算过程是给予$\theta_i$（可计算出$^{i-1}_iT$），然后求出手臂末端位置或坐标。相反，对于逆向运动学（Inverse Kinematics）来说，就是给予手臂末端位置或坐标，求得$\theta_i$。</p><h1 id="求解概念"><a href="#求解概念" class="headerlink" title="求解概念"></a>求解概念</h1><p>假设有一个6DOF的机械臂，未知的joint angles就有6个（$\theta_i$或$d_i$，$i=1,…,6$）。那么它的Transformation Matirx就可以写成这样的形式：<br>$$<br>^0_6T=<br> \left[<br>\begin{array}{ccc|c}<br>  &amp;^0_6R_{3\times3}&amp;&amp;^0P_{6 org 3\times1} \\<br>\hline<br>  0&amp;0&amp;0&amp;1<br>\end{array}<br>\right] _{4\times4}<br>$$<br>对于任何一个Transformation Matrix来说，它们都只有6个自由度，因为虽然旋转矩阵$R$里有九个数字，但是$\hat X, \hat Y, \hat Z$的长度为1，增加了3个限制条件，然后$\hat X, \hat Y, \hat Z$又要两两要垂直，又增加了3个限制条件，所以只有3个自由度，再加上移动向量$P$的3个未知数，一共就有6个自由度。为了解出这个Transformation Matrix，我们需要解出$R$和$P$，一共有12个非线性方程式，再加上6个限制条件，来解6个未知数。所以6自由度的机械臂是没有冗余的，需要用pieper准则来判断机械臂是否有解析解，后面会介绍。但是当机械臂大于6个自由度时，就会有冗余自由度，这时IK就有无数多的解，在实际应用中需要增加限制条件方能求出有效解。</p><h1 id="多重解"><a href="#多重解" class="headerlink" title="多重解"></a>多重解</h1><p>因为那12个方程式是非线性的，所以并不代表具有唯一解，机械手臂的解是由自身结构所决定的。比如，上一讲中提到的PUMA机械手臂（6 DOF），它的前3个DOF是用来控制手臂末端在空间中的位置，对于同一个位置它就有四组解，如下图：<br><img src="1.png" alt=""><br>同时，同一个位置下，手腕部位的转动姿态又有两组解：<br>$$<br>\begin{aligned}<br>&amp;\theta^{‘}_4 = \theta_4 + 180^\circ \\<br>&amp;\theta^{‘}_5 = -\theta_5 \\<br>&amp;\theta^{‘}_6 = \theta_6 + 180^\circ<br>\end{aligned}<br>$$<br>所以针对一些特定工作点，就有2x4=8组解。但是，有时因为手臂本身的几何限制或者空间限制，并不是任何一个解都可以用。当出现多组解时，我们就需要进行选择，选择的方式有：</p><ul><li>选择距离目前状态最近的解，这样最快，最省能。</li><li>选择避开障碍物的解，如果有障碍物就需要考虑进来。</li></ul><h1 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h1><p>求解Inverse Kinematics的方法有两种，<strong>解析法</strong>和<strong>数值法</strong>。解析法就是用代数（algebraic）计算Transformation Matrix并解方程的方法或着几何（geometric）法画图再运用三角函数来计算。而数值法就是是采用某种计算方法，如有限元法， 数值逼近法，插值法等得到的解，其<strong>正确性不如解析法</strong>可靠。目前大多数机械手臂都直接设计成有解析解的。</p><h2 id="举例：RRR机械手臂"><a href="#举例：RRR机械手臂" class="headerlink" title="举例：RRR机械手臂"></a>举例：RRR机械手臂</h2><p>这里以一个RRR机械手臂为例，分别介绍解析法中代数方法和几何方法计算IK问题。<br><img src="2.png" alt=""><br>首先我们计算出它的Transformation Matrix，如下：<br>$$<br>^0_3T=<br>\begin{bmatrix}<br>c_{123} &amp; -s_{123} &amp; 0 &amp; l_1c_1+l_2c_{12} \\<br>s_{123} &amp; c_{123} &amp; 0 &amp; l_1s_1+l_2s_{12} \\<br>0 &amp; 0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{bmatrix}<br>$$<br>我们的目标是得到如下的Transformation Matrix：<br>$$<br>^0_3T=<br>\begin{bmatrix}<br>c_{\phi} &amp; -s_{\phi} &amp; 0 &amp; x \\<br>s_{\phi} &amp; c_{\phi} &amp; 0 &amp; y \\<br>0 &amp; 0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{bmatrix}<br>$$</p><h3 id="几何法"><a href="#几何法" class="headerlink" title="几何法"></a>几何法</h3><p>对于这样一个简单的机械手臂来说，在一些特定的点仍然会有多重解，比如下图所示，手臂到达（x,y）点可以以蓝色折线的姿态，也可以以绿色折线的姿态。计算方式就是先运用余弦定理先计算出$\theta_2$，再利用余弦定理计算出中间角$\psi$，最后算出$\theta_1$和$\theta_3$。<br><img src="3.png" alt=""><br><img src="4.png" alt=""></p><h3 id="代数法"><a href="#代数法" class="headerlink" title="代数法"></a>代数法</h3><p><img src="5.png" alt=""><br><img src="6.png" alt=""><br><img src="7.png" alt=""></p><h2 id="Pieper’s-Solution"><a href="#Pieper’s-Solution" class="headerlink" title="Pieper’s Solution"></a>Pieper’s Solution</h2><p>Pieper准则就是说对于6自由度的机械手臂满足以下两个条件中的一个，就会有解析解。</p><ul><li>三个相邻关节轴相交于一点；</li><li>三个相邻关节轴相互平行。</li></ul><p>比如之前介绍的PUMA机械手臂，它的前三轴是用来产生移动的，后三轴是用来产生转动的，并且相交于一点，满足Pieper准则，$^0P_{6 org} = ^0P_{4 org}$<br><img src="8.png" alt=""><br>首先我们要根据最终的位置解出前三轴的角度。<br><img src="9.png" alt=""><br><img src="10.png" alt=""><br><img src="11.png" alt=""><br><img src="12.png" alt=""><br>在计算$\theta_3$时，用到了一种三角函数方程式求解的方法，如下图：<br><img src="13.png" alt=""><br>到这里，通过位置计算我们已经得到了$\theta_1，\theta_2，\theta_3$，接下来就要计算它的Orientation了。因为已经知道了$\theta_1，\theta_2，\theta_3$，所以就得到了$^0_3R$，从而推导出来$^3_6R=^0_3R^{-1}{^0_6R}$，最后我们就可以用Z—Y—Z Euler angle的方法解出$\theta_4，\theta_5，\theta_6$。但是这里要注意，我们需要把4 frame的Y轴转到5 frame的Z轴位置，这样的话5 frame对Z轴转动就相当于对4 frame的Y轴转动，然后因为4 frame的Z轴与6 frame重合，所以对6 frame的Z轴转动就相当与对4 frame的Z轴转动，但是要注意需要将4 frame转到与6 frame重合，这样就完成了Z—Y—Z的转动。这里用$\theta_4’，\theta_5’，\theta_6’$来说明用Z—Y—Z方法算出来的角度，而$\theta_4，\theta_5，\theta_6$是DH定义的角度，它们之间有一些差异。图解如下：<br><img src="14.png" alt=""><br><img src="15.png" alt=""></p><h3 id="举例：物件取放任务"><a href="#举例：物件取放任务" class="headerlink" title="举例：物件取放任务"></a>举例：物件取放任务</h3><p><img src="16.png" alt=""><br><img src="17.png" alt=""><br><img src="18.png" alt=""><br><img src="19.png" alt=""><br><img src="20.png" alt=""><br><img src="21.png" alt=""><br><img src="22.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向运动学 </tag>
            
            <tag> Inverse Kinematics </tag>
            
            <tag> Pieper Solution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂三--正向运动学</title>
      <link href="/2020/05/09/robot-arm-3/"/>
      <url>/2020/05/09/robot-arm-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在讨论正向运动学之前，我们先了解两个概念，一个是运动学（Kinematics），一个是动力学（Dynamics）。看起来名字都差不多，那么它们有什么差别呢？</p><ul><li>运动学（Kinematics）：讨论的是运动状态，未联系到产生运动的<strong>力</strong>。也就是位移，速度，加速度和时间之间的关系，比如$v=\frac{d}{dt}x$，$a=\frac{d}{dt}v$。</li><li>动力学（Dynamics）：讨论的是<strong>力</strong>和<strong>力矩</strong>是如何产生运动的。比如，$\sum F=ma$。</li></ul><p>在了解完运动学的概念后，那么什么是正向运动学呢？假设我们有一个简单的机械臂，如下图所示：<br><img src="1.png" alt=""><br>当我们知道了$l_1,l_2,l_3,\theta_1,\theta_2,\theta_3$时，通过简单的三角函数计算我们就可以一步一步的计算出机械臂末端点P所在的位置，那么这个就叫做正向运动学。反之，如果我们想要机械臂末端点P到达某个位置，那么我们就需要知道这个位置所对应的$\theta_1,\theta_2,\theta_3$，这个过程就是反向运动学（Inverse Kinematics），这个我们在下一讲介绍。</p><h1 id="机械手臂的几何描述"><a href="#机械手臂的几何描述" class="headerlink" title="机械手臂的几何描述"></a>机械手臂的几何描述</h1><p>机械手臂是由多个杆件（link）和关节（joint）所组成的。</p><ul><li>机械手臂的关节不但可以进行转动（revolute）还可以进行移动（prismatic），每个关节的运动都会沿着<strong>某特定axis</strong>进行。</li><li>机械手臂的杆件的作用就是将各个关节连接起来。</li></ul><p>为了计算出机械臂末端点所在空间的位置，我们需要一步一步的找到各个joint在空间中的位置，因此我们可以在每一个joint上建立坐标系，然后利用上一讲中介绍的Transformation Matrix来计算各个坐标系在空间中的位置，这样我们就间接的知道了各个joint的位置。</p><h2 id="第一步：建立frame"><a href="#第一步：建立frame" class="headerlink" title="第一步：建立frame"></a>第一步：建立frame</h2><p>在joint上建立坐标系的方式如下：</p><ul><li>首先要确定所有joint的$\hat Z$轴的方向，$\hat Z$轴就是这个joint转动或移动的方向。</li><li>然后再确定$\hat X_i$的方向，要沿着$a_i$的方向，$a_i$就是$\hat Z_i$和$\hat Z_{i+1}$之间的距离。但是，当$a_i=0$也就是说$\hat Z_i$和$\hat Z_{i+1}$相交时，$\hat X_i$要取和$\hat Z_i$和$\hat Z_{i+1}$两者都垂直的方向。</li><li>最后再确定$\hat Y_i$的方向，与$\hat X_i$和$\hat Z_i$两者垂直并遵循右手定则（拇指X，食指Y，中指Z）。<br><img src="2.png" alt=""></li></ul><h2 id="第二步：Denavit-Hartenberg表达法（Craig-version）"><a href="#第二步：Denavit-Hartenberg表达法（Craig-version）" class="headerlink" title="第二步：Denavit-Hartenberg表达法（Craig version）"></a>第二步：Denavit-Hartenberg表达法（Craig version）</h2><p>Denavit-Hartenberg表达法简称为DH表达法，它可以用4个参数来表达两个joint之间的关系。因此，如果将所有joint的关系整合起来形成一个表格，那么这个表格就可以用来表达完整的机械手臂，我们把这个表格叫做DH表，那4个参数分别为：$\alpha,a,d,\theta$。</p><ul><li>$\alpha_{i-1}$：是两个joint之间的夹角，计算方法是沿着$\hat X_{i-1}$的方向看过去，从$\hat Z_{i}$转到$\hat Z_{i-1}$的角度，顺时针为负，逆时针为正。</li><li>$a_{i-1}$：是两个joint之间的距离，计算方法是沿着$\hat X_{i-1}$的方向看过去，$\hat Z_{i-1}$到$\hat Z_i$的距离，可正可负。</li><li>$\theta_i$：对于转动的joint来说，这个值是变量。计算方法是沿着$\hat Z_{i}$的方向看过去，从$\hat X_{i}$转到$\hat X_{i-1}$的角度，顺时针为负，逆时针为正。</li><li>$d_i$：对于移动的joint来说，这个值是变量。计算方法是沿着$\hat Z_{i}$的方向看过去，从$\hat X_{i-1}$到$\hat X_{i}$的距离，可正可负。<br><img src="3.png" alt=""></li></ul><h2 id="第三步：计算每个joint之间的Transformation-Matrix"><a href="#第三步：计算每个joint之间的Transformation-Matrix" class="headerlink" title="第三步：计算每个joint之间的Transformation Matrix"></a>第三步：计算每个joint之间的Transformation Matrix</h2><p>接下来我们就要计算出每个joint之间的Transformation Matrix，计算方式如下：<br>$$<br>^{i-1}_iT=T_{\hat X_{i-1} }(\alpha_{i-1})T_{\hat X_R}(a_{i-1})T_{\hat Z_Q}(\theta_i)T_{\hat Z_P}(d_i) \\<br>= \begin{bmatrix}<br>c\theta_i &amp; -s\theta_i &amp; 0 &amp; a_{i-1}  \\<br>s\theta_ic\alpha_{i-1} &amp; c\theta_ic\alpha_{i-1} &amp; -s\alpha_{i-1} &amp; -s\alpha_{i-1}d_i  \\<br>s\theta_is\alpha_{i-1} &amp; c\theta_is\alpha_{i-1} &amp; c\alpha_{i-1} &amp; c\alpha_{i-1}d_i \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$$<br><img src="4.png" alt=""><br>计算的过程都是遵循上一讲所说的Eular Angles的情况，所以计算过程都是右乘。首先呢，先将i-1 frame沿着X轴转动到R frame，再沿着X轴移动到Q frame，接着再沿着Z轴转动到P frame，最后呢再沿着Z轴移动到i frame，就得到了我们最终想要的$^{i-1}_iT$。<br>同样的，它也可以进行多个Transformation Matrix连乘：<br>$$<br>^{i-1}_iT=^{0}_1T^{1}_2T^{2}_3T…^{n-2}_{n-1}T^{n-1}_nT<br>$$</p><blockquote><p>Note: 通过这种方式我们就可以得到任意joint相对于基坐标（0 frame）的Transformation Matrix，从而得到任意joint相对于基坐标的位置。</p></blockquote><h3 id="举例-PUMA-560-1"><a href="#举例-PUMA-560-1" class="headerlink" title="举例 PUMA 560 -1"></a>举例 PUMA 560 -1</h3><h4 id="建立frame"><a href="#建立frame" class="headerlink" title="建立frame"></a>建立frame</h4><p>PUMA 560-1机械手臂坐标系的建立如下图所示，当然这并不是唯一的方法，X轴，Y轴，Z轴的方向都可以和下图所示的方法相反，只不过不同的方法会建立不同的DH表。<br><img src="5.png" alt=""></p><blockquote><p>Note: </p><ol><li>0 frame是基坐标，可以定在任意位置。</li><li>$\hat Z_1$与$\hat Z_2$相交，所以$\hat X_1$的方向要垂直与$\hat Z_1$和$\hat Z_2$</li></ol></blockquote><h4 id="建立DH表"><a href="#建立DH表" class="headerlink" title="建立DH表"></a>建立DH表</h4><p>DH表如下图所示。因为我们的手臂有6个DOF，所以i的取值就从1-6。1代表1 frame，2代表2 frame，以此类推。首先看第一行，因为0 frame和1 frame完全重合，所以$\alpha_0, a_0, d_1$都是0，唯一可能会变的就是$\theta_1$这个变量。第二行中，沿着$\hat X_{1}$的方向看过去，从$\hat Z_{2}$转到$\hat Z_{1}$的角度为顺时针$90^\circ$，所以$\alpha_1=-90^\circ$。$\hat Z_{1}$到$\hat Z_{2}$的距离为0，所以$a_1=0$，$\hat X_{1}$到$\hat X_{2}$的距离为0，所以$d_1=0$，$\theta_2$同样是变量。以此类推就可以得到整个DH表。<br><img src="6.png" alt=""></p><h4 id="计算Transformation-Matrix"><a href="#计算Transformation-Matrix" class="headerlink" title="计算Transformation Matrix"></a>计算Transformation Matrix</h4><p>计算的方式就是将DH表里的参数带入之前介绍的计算Transformation Matrix的公式里，结果如下图：<br><img src="7.png" alt=""><br><img src="8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正向运动学 </tag>
            
            <tag> Forward Kinematics </tag>
            
            <tag> DH表达法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂二--旋转矩阵和变换矩阵的计算</title>
      <link href="/2020/05/05/robot-arm-2/"/>
      <url>/2020/05/05/robot-arm-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="旋转矩阵与转角的关系"><a href="#旋转矩阵与转角的关系" class="headerlink" title="旋转矩阵与转角的关系"></a>旋转矩阵与转角的关系</h1><p>上一讲中我们介绍了质点沿着某一坐标轴旋转的旋转矩阵的计算方法，但是在更普遍的情况下，质点的旋转并不是沿着某一坐标轴，而可能是空间中的任意轴。所以这一讲我们将介绍如何通过拆解为沿坐标轴旋转的方式来计算任意旋转矩阵。</p><p>拆解的方式有两种：</p><ol><li>Fixed angles – 根据一个固定不动的坐标系进行旋转</li><li>Euler angles – 对转动后的坐标系再此进行旋转</li></ol><h2 id="Fixed-angles"><a href="#Fixed-angles" class="headerlink" title="Fixed angles"></a>Fixed angles</h2><p>如下图所示，A frame是固定不变的坐标系，我们先沿着$\hat{X}$轴旋转$\gamma$角度，再沿着$\hat{Y}$轴旋转$\beta$角度，最后沿着$\hat{Z}$轴旋转$\alpha$角度得到了B frame。<br><img src="1.png" alt=""><br>旋转矩阵的计算方式如下：<br>$$<br>\begin{aligned}<br>&amp;^A_BR_{XYZ}(\gamma,\beta,\alpha) =<br>R_Z(\alpha)R_Y(\beta)R_X(\gamma) \\<br>&amp;=    \begin{bmatrix}<br>    c\alpha c\beta &amp; c\alpha s\beta s\gamma - s\alpha c\gamma &amp; c\alpha s\beta c\gamma + s\alpha s\gamma \\<br>    s\alpha c\beta &amp; s\alpha s\beta s\gamma + c\alpha c\gamma &amp; s\alpha s\beta c\gamma - c\alpha s\gamma \\<br>    -s\beta &amp; c\beta s\gamma &amp; c\beta c\gamma<br>    \end{bmatrix} \\<br>&amp;= \begin{bmatrix}<br>r_{11} &amp; r_{12} &amp; r_{13}  \\<br>r_{21} &amp; r_{22} &amp; r_{23}  \\<br>r_{31} &amp; r_{32} &amp; r_{33}  \\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><blockquote><p>Note: Fixed angles下，旋转矩阵采用的是左乘的方式计算。</p></blockquote><p>当我们已知旋转矩阵R时，怎么反推出来旋转的角度呢？根据$r_{31}$元素的值我们可以直接算出$\beta$角，然而$\beta$角的取值会有如下三种情况：<br>如果$\beta \neq \pm90^\circ$：<br>$$<br>\begin{aligned}<br>\beta &amp;= Atan2(-r_{31}, \sqrt{r_{11} ^2 + r_{21} ^2}) \\<br>\alpha &amp;= Atan2(r_{21}/c\beta, r_{11}/c\beta) \\<br>\gamma &amp;= Atan2(r_{32}/c\beta, r_{33}/c\beta)<br>\end{aligned}<br>$$<br>如果$\beta = 90^\circ$：<br>$$<br>\begin{aligned}<br>&amp;\alpha = 0^\circ \\<br>&amp;\gamma = Atan2(r_{12},r_{22})<br>\end{aligned}<br>$$<br>如果$\beta = -90^\circ$：<br>$$<br>\begin{aligned}<br>&amp;\alpha = 0^\circ \\<br>&amp;\gamma = -Atan2(r_{12},r_{22})<br>\end{aligned}<br>$$</p><blockquote><p>Note: 当$\beta \neq \pm90^\circ$时，$\alpha$和$\gamma$其实有多组解，这里我们给$\alpha$取$0^\circ$是为了方便计算</p></blockquote><h2 id="Euler-angles（Z-Y-X）"><a href="#Euler-angles（Z-Y-X）" class="headerlink" title="Euler angles（Z-Y-X）"></a>Euler angles（Z-Y-X）</h2><p>如下图所示，A frame是我们即将要旋转的坐标系，首先我们先沿着$\hat{Z}$轴旋转$\alpha$角度，再沿着旋转之后的坐标系的$\hat{Y}$轴旋转$\beta$角度，最后再沿着$\hat{X}$轴旋转$\gamma$角度得到了B frame。<br><img src="2.png" alt=""><br>旋转矩阵的计算方式如下：<br>$$<br>\begin{aligned}<br>&amp;^A_BR_{ZYX}(\alpha,\beta,\gamma) =<br>R_Z(\alpha)R_Y(\beta)R_X(\gamma) \\<br>&amp;=    \begin{bmatrix}<br>    c\alpha c\beta &amp; c\alpha s\beta s\gamma - s\alpha c\gamma &amp; c\alpha s\beta c\gamma + s\alpha s\gamma \\<br>    s\alpha c\beta &amp; s\alpha s\beta s\gamma + c\alpha c\gamma &amp; s\alpha s\beta c\gamma - c\alpha s\gamma \\<br>    -s\beta &amp; c\beta s\gamma &amp; c\beta c\gamma<br>    \end{bmatrix} \\<br>&amp;= \begin{bmatrix}<br>r_{11} &amp; r_{12} &amp; r_{13}  \\<br>r_{21} &amp; r_{22} &amp; r_{23}  \\<br>r_{31} &amp; r_{32} &amp; r_{33}  \\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><blockquote><p>Note: Euler angles下，旋转矩阵采用的是右乘的方式计算。</p></blockquote><p>我们发现与X-Y-Z fixed angle得到同样的旋转矩阵，所以Fix angle下以X-Y-Z来转就等于Eular angle下以Z-Y-X来转。因为旋转矩阵是一样的，那么反推旋转角度的计算方式和Fixed angle也是一样的。</p><h2 id="Euler-angles（Z-Y-Z）"><a href="#Euler-angles（Z-Y-Z）" class="headerlink" title="Euler angles（Z-Y-Z）"></a>Euler angles（Z-Y-Z）</h2><p>Euler angles还有一种旋转方式就是Z-Y-Z，即我们先沿着$\hat{Z}$轴旋转$\alpha$角度，再沿着旋转之后的坐标系的$\hat{Y}$轴旋转$\beta$角度，最后再沿着$\hat{Z}$轴旋转$\gamma$角度。如下图所示：<br><img src="3.png" alt=""><br>旋转矩阵的计算方式如下：<br>$$<br>\begin{aligned}<br>&amp;^A_BR_{ZYZ}(\alpha,\beta,\gamma) =<br>R_Z(\alpha)R_Y(\beta)R_Z(\gamma) \\<br>&amp;=    \begin{bmatrix}<br>    c\alpha c\beta c\gamma - s\alpha s\gamma &amp; -c\alpha c\beta s\gamma - s\alpha c\gamma &amp; c\alpha s\beta \\<br>    s\alpha c\beta c\gamma + c\alpha s\gamma &amp; -s\alpha c\beta s\gamma + c\alpha c\gamma &amp; s\alpha s\beta \\<br>    -s\beta c\gamma &amp; s\beta s\gamma &amp; c\beta<br>    \end{bmatrix} \\<br>&amp;= \begin{bmatrix}<br>r_{11} &amp; r_{12} &amp; r_{13}  \\<br>r_{21} &amp; r_{22} &amp; r_{23}  \\<br>r_{31} &amp; r_{32} &amp; r_{33}  \\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><blockquote><p>Note: Euler angles下，旋转矩阵采用的是右乘的方式计算。</p></blockquote><p>要计算旋转的角度，我们首先根据$r_{33}$元素的值算出$\beta$角，然而$\beta$角的取值依然会有如下三种情况：<br>如果$\beta \neq 0^\circ or 180^\circ$：<br>$$<br>\begin{aligned}<br>\beta &amp;= Atan2(\sqrt{r_{31} ^2 + r_{32} ^2}, r_{33} ) \\<br>\alpha &amp;= Atan2(r_{23}/s\beta, r_{13}/s\beta) \\<br>\gamma &amp;= Atan2(r_{32}/s\beta, -r_{31}/s\beta)<br>\end{aligned}<br>$$<br>如果$\beta = 0^\circ$：<br>$$<br>\begin{aligned}<br>&amp;\alpha = 0^\circ \\<br>&amp;\gamma = Atan2(-r_{12},r_{11})<br>\end{aligned}<br>$$<br>如果$\beta = 180^\circ$：<br>$$<br>\begin{aligned}<br>&amp;\alpha = 0^\circ \\<br>&amp;\gamma = -Atan2(r_{12},-r_{11})<br>\end{aligned}<br>$$</p><h1 id="Transformation-matrix"><a href="#Transformation-matrix" class="headerlink" title="Transformation matrix"></a>Transformation matrix</h1><p>因为刚体在空间中的状态有移动$\vec{P}$和转动$R$两种，为了方便计算我们需要将这两种状态整合到一个矩阵里计算，因此我们引入了变换矩阵：<br>$$<br>^A_BT=<br> \left[<br>\begin{array}{ccc|c}<br>  &amp;^A_BR_{3\times3}&amp;&amp;^AP_{B org 3\times1}\\<br>\hline<br>  0&amp;0&amp;0&amp;1<br>\end{array}<br>\right] _{4\times4}<br>$$</p><h2 id="Transformation-matrix的应用"><a href="#Transformation-matrix的应用" class="headerlink" title="Transformation matrix的应用"></a>Transformation matrix的应用</h2><p>Transformation matrix的应用有两种情况：一种是已知某个质点在一个坐标系的位置，通过两个坐标系的变换矩阵来计算这个质点在另一个坐标系的位置；另一种是在同一个坐标系下，计算某质点经过移动和旋转后的新的坐标。</p><p>在第一种情况下，例如，已知P点在B frame下的坐标，以及B frame对A frame的Transformation matrix，那么P点在A frame的坐标就是：<br>$$<br>\begin{bmatrix}<br>^AP \\<br>1<br>\end{bmatrix} =<br>\begin{bmatrix}<br>  &amp;^A_BR&amp;&amp;^AP \\<br>  0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>^BP \\<br>1<br>\end{bmatrix} =<br>\begin{bmatrix}<br>^A_BR^BP+^AP_{Borg} \\<br>1<br>\end{bmatrix}<br>$$</p><blockquote><p>Note: Tranforamtion Matrix是可以连续操作的:$^A_BT=^A_CT^C_DT^D_BT$<br>这样的话，我们只要是知道任何坐标系之间的T，就可以知道任意点在不同坐标系下的坐标。</p></blockquote><p>在第二种情况下，如果质点是先转动再移动的话，那么计算方式和第一种情况相同，因为我们看最终P点在A frame下的表达式：$^AP_2 = R^AP_1+P$，P点先左乘R进行了转动，才加上偏移量进行了移动，只不过这里的P和R都是相对于自身坐标系来说的。如果是先移动再转动的话，表达式应该是这样：$^AP_2 = R(^AP_1+P)$，结果完全不同。</p><h2 id="Transformation-matrix的运算"><a href="#Transformation-matrix的运算" class="headerlink" title="Transformation matrix的运算"></a>Transformation matrix的运算</h2><ol><li>连续运算<br>$$<br>^AP=^A_BT^BP=^A_BT(^B_CT^CP)=^A_BT^B_CT^CP<br>$$</li><li>反矩阵（计算过程省略）</li></ol><p>$$<br>^A_BT^{-1}=<br>\begin{bmatrix}<br>  &amp;^A_BR^T&amp;&amp;-^A_BR^T{^AP_{Borg} } \\<br>  0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p><ol start="3"><li><p>连续运算，求未知T<br>已知$^U_DT=^U_AT^A_DT=^U_BT^B_CT^C_DT$，如图：<img src="4.png" alt=""><br>如果$^C_DT$不知道，那么<br>$$<br>^C_DT=(^U_BT^B_CT)^{-1}{^U_AT^A_DT}<br>$$</p></li><li><p>连续运算法则<br>假设有两个frame，A和B，然而B frame需要经过$T_1$，$T_2$，$T_3$三次按照转轴旋转和移动才能与A重合。那么，如果B frame是按照A frame的转轴旋转，$^A_BT=T_3T_2T_1I$，要按照左乘的规则，这就是前面讲的fixed angles的情况；如果B frame是按照B frame自身的转轴旋转，$^A_BT=IT_1T_2T_3$，要按照右乘的规则，这就是前面讲的Euler angles的情况。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rotation Matrix </tag>
            
            <tag> Transformation Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂一--刚体的运动状态</title>
      <link href="/2020/05/04/robot-arm-1/"/>
      <url>/2020/05/04/robot-arm-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>刚体在空间中的运动方式有两种，一种是移动，一种是转动，它们各有3个DOF。对于移动来说，它可以沿着$\hat{X}$轴，$\hat{Y}$轴和$\hat{Z}$轴移动， 同样的，转动也可以沿着$\hat{X}$轴，$\hat{Y}$轴和$\hat{Z}$轴进行转动。为了描述刚体在空间中的运动状态，我们通常会在它的质心位置建立一个坐标系（frame）, 通过得到这个坐标系与世界坐标系之间的关系，我们可以知道这个刚体在空间中的姿态。</p><h1 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h1><p>刚体的移动可以用向量$\vec{P}$来描述，它即明确了移动的方向，又说明了移动的大小。如下图：<br><img src="1.png" alt=""><br>因为位置是相对的，为了表明$\vec{P}$是以A frame为基坐标上B frame的位置，我们通常写为$^AP_B org$，其中org指的是B frame的原点，即刚体的质心。</p><h1 id="转动"><a href="#转动" class="headerlink" title="转动"></a>转动</h1><p>刚体的转动需要用三个向量来描述，因此我们将它写成矩阵的形式，并将这个矩阵称之为旋转矩阵（Rotation Matrix），用$^A_BR$来表示（B frame相对于A frame）。$^A_BR$的三个columns其实是B frame的$\hat{X}$轴，$\hat{Y}$轴以及$\hat{Z}$轴方向的单位向量在A frame下的投影，因此旋转矩阵的三个cloumns的长度都为1。如图：<br><img src="2.png" alt=""></p><h2 id="旋转矩阵的特性"><a href="#旋转矩阵的特性" class="headerlink" title="旋转矩阵的特性"></a>旋转矩阵的特性</h2><p>旋转矩阵有如下特性：</p><ul><li>$^A_BR$=$^B_AR^T\to$ B对A的旋转矩阵就相当于A对B的旋转矩阵的转置</li><li>$^A_BR^T$=$^A_BR^{-1}$=$^B_AR\to$ 旋转矩阵的逆矩阵等于它的转置。这个特性非常有用，因为逆矩阵的计算往往需要很大的计算量，有了这个特性，我们就可以很容易的得到旋转矩阵的逆矩阵。</li></ul><h2 id="旋转矩阵的使用"><a href="#旋转矩阵的使用" class="headerlink" title="旋转矩阵的使用"></a>旋转矩阵的使用</h2><p>旋转矩阵除了可以描述B frame相对于A frame的姿态以外，也可以计算向量在不同frame下的坐标。比如有一个在B frame下的向量$^BP$，那么它在A frame下的坐标就可以这样得到: $^AP$=$^A_BR$$^BP$<br>以上的应用都是在已知两个frame的旋转矩阵下进行的，当有一个向量要在同一个frame下沿某个轴转动某个角度时，我们就需要计算出旋转矩阵，计算方式如下：<br>$$<br>R_{ {\hat{X} }_A}(\theta)=<br>    \begin{bmatrix}<br>    1 &amp; 0 &amp; 0 \\<br>    0 &amp; cos\theta &amp; -sin\theta \\<br>    0 &amp; sin\theta &amp; cos\theta<br>    \end{bmatrix}<br>$$$$<br>R_{ {\hat{Y} }_A}(\theta) =<br>    \begin{bmatrix}<br>    cos\theta &amp; 0 &amp; sin\theta \\<br>    0 &amp; 1 &amp; 0 \\<br>    -sin\theta &amp; 0 &amp; cos\theta<br>    \end{bmatrix}<br>$$$$<br>R_{ {\hat{Z} }_A}(\theta) =<br>    \begin{bmatrix}<br>    cos\theta &amp; -sin\theta &amp; 0 \\<br>    sin\theta &amp; cos\theta &amp; 0 \\<br>    0 &amp; 0 &amp; 1<br>    \end{bmatrix}<br>$$<br>例如有点$^AP$对$\hat{X}_A$轴转动$\theta$角度后得到了点$^AP’$,那么点$^AP’$的坐标就是：$$<br>    ^AP’=R_{ {\hat{X} }_A}(\theta)^AP<br>$$注意：点$^AP’$的坐标是基于{A}的，而不是旋转后的坐标{A’}的。</p>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刚体运动 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
