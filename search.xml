<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FPV穿越机-基础知识</title>
      <link href="/2020/12/25/fpv-1/"/>
      <url>/2020/12/25/fpv-1/</url>
      
        <content type="html"><![CDATA[<h1 id="机架"><a href="#机架" class="headerlink" title="机架"></a>机架</h1><p>机架的功能相当于整个穿越机的一个大底盘，它会承载整个穿越机的所有东西。对于机架的挑选首先确定的就是机架的大小，也就是轴距。轴距指的是两个对角的电机之间的距离，通常有210，190这要的叫法，也就是说两个对角电机的距离为210mm或者是190mm。有的人所说的5寸机，3寸机，其实指的是螺旋桨的大小，对应5寸浆或者是3寸浆。</p><h1 id="电池"><a href="#电池" class="headerlink" title="电池"></a>电池</h1><p>用功能相当于整个穿越机的一个大底盘，它会承载整个穿越机的所有东西。对于机架的挑选首先确定的就是机架的大小，也就是轴距。轴距指的是两个对角的电机之间的距离，通常有210，190这要的叫法，也就是说两个对角电机的距离为210mm或者是190mm于航模使用的电池大多数都是聚合物锂电池，他们大致可以分为两类：一类为航模电机供电，另一类为遥控器供电也称为控电。他们之间的不同点就是放电倍率不同，接下来我们就了解一些电池的参数：</p><ul><li>电压：电池上标定的电压是额定电压，但不代表电池就会一直保持这个电压，电池的电压会在额定电压附近波动，电压越低说明电量越少，电压越高说明电量越多。</li><li>S和P：S指的是串联，P指的是并联。nSmP的电池指的是有n块电芯串联起来然后有m个这样的串联电池组并联起来。通常航模电池都没有并联也就是只有1P，所以直接称为3S、4S电池。锂聚合物电池单片电芯的额定电压为3.7V，所以3S电池的额定电压就为11.1V，以此类推。</li><li>mah（毫安时）：用来表示电池的容量，xxxxmah就是说这个电池能以xxxxmA的电流持续放电1小时。</li><li>Wh（瓦时）：同样用来表示电池容量，计算方法就是用电压乘以mah。</li><li>Discharge Rate（放电倍率）：也就是电池所能提供的最大放电电流，例如一块放电倍率为85C的电池，电池容量为2200mah，那么最大放电电流为$I_{max}=2.2Ah \times 85C=187A$</li><li>Charge Rate（充电倍率）：与计算最大放电电流一样的方法，可以得到最大充电电流。</li></ul><h1 id="电调"><a href="#电调" class="headerlink" title="电调"></a>电调</h1><p>电调，全称电子调速器，英文全称Electronic Speed Control，简称ESC。根据搭配电机的不同，电调可分为有刷电调和无刷电调。在使用电调前要对电调进行油门行程校准或者编程设置，具体看说明书。接下来我们了解一下ESC的一些参数：</p><ul><li>Battery Eliminator Circuit（BEC）：带BEC的电调会通过动力电池引出一路5V电压给接收机，舵机等设备供电。而对于多轴飞行器的电调来说通常不带BEC，5V低电压可以从分电板引出。</li><li>xxA：这个参数说明了电调所能承受的最大电流，要买哪一个电调还得看电机的最大持续电流以及厂家推荐的电调型号，只要电机的最大持续电流不超过带你调标称的电流就可以了。</li><li>x-xS：这里说明了适用的电池型号，比如2-3S LIPO，就是说使用于2S或3S的锂电池。</li></ul><h1 id="电机"><a href="#电机" class="headerlink" title="电机"></a>电机</h1><p>目前大多数航模电机都采用外转子无刷电机，也有少数小型航模采用有刷电机，例如空心杯。有刷电机两端接电池就可以旋转，反向电压后就可以反向旋转，电压的大小决定了电机的转速，所以通常用PWM来控制电机转速。无刷电机则是通过ESC控制电机转速，当ESC收到控制信号后将输出三相交流电来控制无刷电机，因此电机上的三根线是没有区别的，电机顺时针还是逆时针转动与ESC给这三根线供电的顺序有关，如果通电后发现电机转向不正确，将两根线互换次序即可。接下来我们就了解一下电机的参数：</p><ul><li>电机尺寸：例如2212，这个参数指的是电机的尺寸，其中22指的是电机定子的直径是22mm，12指的是定子的长度是12mm。</li><li>KV值：例如980KV，这个参数表示电机在空载理想状态下，输入电压每增加1V电机转速增加980r/min。</li><li>搭配螺旋桨：通常螺旋桨越大，拉力越大，但是由于电机的KV值越高，扭矩就会越小，所以低KV值的电机搭配大尺寸螺旋桨，高KV值的电机搭配小尺寸螺旋桨。</li></ul><h1 id="螺旋桨"><a href="#螺旋桨" class="headerlink" title="螺旋桨"></a>螺旋桨</h1><p>螺旋桨首先最直观可以看到的就是它的叶片数量，有2叶浆、3叶浆、4叶浆。浆数越多飞机的力量就越大，所以电机就需要提供更大的扭矩。再一个就是它的尺寸参数了，就像电机的尺寸一样，会由4个数字组成比如5045，前两个数字50指的就是浆的直径为5.0英寸，后面两个数字是螺距，指的是螺旋桨在一个致密介质中旋转一圈所行进的距离为4.5英寸。</p>]]></content>
      
      
      <categories>
          
          <category> 穿越机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPV </tag>
            
            <tag> 穿越机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运动规划四--Artificial Potential Fields</title>
      <link href="/2020/08/24/motion-plan-4/"/>
      <url>/2020/08/24/motion-plan-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以CJ Taylor老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics-motion-planning/home/welcome" target="_blank" rel="noopener">Robotics: Computational Motion Planning</a>为参考，进行归纳整理。</p></blockquote><h1 id="Artificial-Potential-Fields"><a href="#Artificial-Potential-Fields" class="headerlink" title="Artificial Potential Fields"></a>Artificial Potential Fields</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本节我们将介绍如何在人工势能场中引导机器人在充满障碍物的环境中运动，基本思路是在Cspace内构造一个平滑的函数，当机器人靠近障碍物时该函数值较高；远离障碍物时，函数值较低。同时，我们还希望在目标点时函数值最低，当远离这个点时函数值增加。如果我们可以构造这样一个函数，我们就可以用它的导数来导航机器人到目标点。本节将以下图所示的2D Cspace为例，红色的点是目标点。<br><img src="1.png" alt=""></p><h2 id="Constructing-an-Attractive-Potential-Field"><a href="#Constructing-an-Attractive-Potential-Field" class="headerlink" title="Constructing an Attractive Potential Field"></a>Constructing an Attractive Potential Field</h2><p>首先我们要构造一个吸引函数，当点在目标点时函数值最小，远离目标点时函数值增大。我们可以用一个二次函数$f_a(x)$来实现：<br>$$<br>f_a(x)=\xi (||x-x_g||^2) \\<br>$$其中$x$是robot现在的位置，$x_g$是目标位置，$\xi$是一个常数。如下图所示，这个函数的图像像一个碗。如果机器人按照这个函数的梯度走，它就会引导机器人朝着目标点前进。<br><img src="2.png" alt=""></p><h2 id="Constructing-a-Repulsive-Potential-Field"><a href="#Constructing-a-Repulsive-Potential-Field" class="headerlink" title="Constructing a Repulsive Potential Field"></a>Constructing a Repulsive Potential Field</h2><p>除了要到达目标位置外，我们还希望机器人可以绕开障碍物，为此我们有了第二个函数$f_r(x)$，它是排斥函数，当机器人靠近障碍物时函数值增大，远离障碍物时函数值减小。<br>$$<br>f_r(x) =<br>\begin{cases}<br>\eta (\frac{1}{\rho (x)}-\frac{1}{d_0})^2 &amp; if\rho(x)\le d_0 \\<br>0 &amp; if\rho(x)\gt d_0<br>\end{cases}<br>$$其中x是Cspace中的一个点，$\eta$是一个常数，$d_0$是一个参数，只有当机器人的位置距离障碍物小于$d_0$时，这个方程才有作用。如下图所示，像一座座山丘一样。<br><img src="3.png" alt=""></p><h2 id="The-Combined-Potential-Field"><a href="#The-Combined-Potential-Field" class="headerlink" title="The Combined Potential Field"></a>The Combined Potential Field</h2><p>有了这两个field之后，我们就可以简单的将他们叠加起来，attractive potential field会吸引机器人到目标点，repulsive potential field则会帮助机器人避开障碍物。如下图所示：<br><img src="4.png" alt=""></p><h2 id="Gradient-Based-Control-Strategy"><a href="#Gradient-Based-Control-Strategy" class="headerlink" title="Gradient Based Control Strategy"></a>Gradient Based Control Strategy</h2><p>在有了这两个场的叠加场后，我们就可以利用它的导数来进行导航，那么机器人移动的方向可以用如下方式得到：<br>$$<br>\mathbf v \propto - \nabla f(x) = -\begin{pmatrix}<br>\frac {\partial f(x)}{\partial x_1} \\<br>\frac {\partial f(x)}{\partial x_2}<br>\end{pmatrix}<br>$$在选择一个机器人的移动速度||v||，这里可以选择一个恒定的速度，也可以根据与目标的距离来切换速度，可以让机器人在接近目标点时减速，避免冲过头。<br><img src="5.png" alt=""></p><h2 id="Quiver-Plot"><a href="#Quiver-Plot" class="headerlink" title="Quiver Plot"></a>Quiver Plot</h2><p>用箭头来表示各个点在Cspace里的梯度方向，有了这样的图之后，机器人只要知道它的位置以及一些自身速度以及姿态数据就能完成导航任务。<br><img src="6.png" alt=""><br>下图是几个例子：<br><img src="7.png" alt=""></p><h1 id="Issue-with-Artificial-Potential-Fields"><a href="#Issue-with-Artificial-Potential-Fields" class="headerlink" title="Issue with Artificial Potential Fields"></a>Issue with Artificial Potential Fields</h1><p>理想情况下，人工势能场只会在终点处出现全局最小值，但是在实际中，除终点外在其他位置也可能出现局部最小值的情况。如下图所示的Cspace以及它的势能场：<br><img src="8.png" alt=""><br>在这种情况下，机器人能否到达目标点取决于机器人的起始位置。下图展示了机器人落入局部最小点的例子：<br><img src="9.png" alt=""></p><h1 id="Generalizing-Potential-Fields"><a href="#Generalizing-Potential-Fields" class="headerlink" title="Generalizing Potential Fields"></a>Generalizing Potential Fields</h1><p>对于复杂的机器人系统比如RRRRRR Arm来说，我们可以在它的表面上设定一系列的控制点，然后每一个控制点可以一个Cspace，$P_i(x)$。对于每一个控制点可以算出它的artificial potential field，$f_i(P_i(x))$。最终的artificial potential field就是将它们都加起来，$f(x)=\sum {_i}f_i(P_i(x))$。最后用偏导数计算每一个控制点的速度：<br>$$<br>\mathbf v \propto - \nabla f(x) = -\begin{pmatrix}<br>\frac {\partial f(x)}{\partial x_1} \\<br>\cdot \\<br>\cdot \\<br>\cdot \\<br>\frac {\partial f(x)}{\partial x_n}<br>\end{pmatrix}<br>$$但是这些点的位置要如何控制，还需要反推到实际机器手臂的每个joint的转动角度。<br><img src="10.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 运动规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> motion planning </tag>
            
            <tag> 运动规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运动规划三--Sample Based Motion Planning Methods</title>
      <link href="/2020/08/22/motion-plan-3/"/>
      <url>/2020/08/22/motion-plan-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以CJ Taylor老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics-motion-planning/home/welcome" target="_blank" rel="noopener">Robotics: Computational Motion Planning</a>为参考，进行归纳整理。</p></blockquote><h1 id="Probabilistic-Road-Maps"><a href="#Probabilistic-Road-Maps" class="headerlink" title="Probabilistic Road Maps"></a>Probabilistic Road Maps</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>之前，我们介绍了Cspace，还讨论了如何构造collision check function来检查Cspace中的某个点是否存在碰撞，从而判断这个点是否处于free space。我们还讨论了一个简单的规划方案，对Cspace进行采样，然后用collision check function来进行检查，将free space的各点连接起来形成一个图，从而进行路径规划。但是这个方法在Cspace是2D或3D时是可行的，对于更高维度的Cspace样本数量是巨大的。这里介绍另一种方法来减少采样量，它在Cspace中采样是随机的，而不是均匀的。</p><h2 id="Probabilistic-Road-Maps过程"><a href="#Probabilistic-Road-Maps过程" class="headerlink" title="Probabilistic Road Maps过程"></a>Probabilistic Road Maps过程</h2><p>Probabilistic Road Map简称为PRM，它建立图的方法是：第一步我们在Cspace里随机产生一个点x，如果这个点在free space里，那么就用Dist Function找到离它较近的k个点，k是自己设定的；第二步试着连接x和这k个点并且用LocalPlaner进行判断这个线能否不经过障碍物连接起来，如果可以的话就形成了一条新的边；第三步重复第一步和第二步n次，n也是自己设定的。所以说这个方法需要自己设定图中点的数量以及每个点周围最多与几个点相连。结束了之后我们就在free space建立了一个图。下图说明了增加一个点的过程，增加的点为绿色，增加的线为绿色实线，无法增加的点为绿色虚线。<br><img src="1.png" alt=""></p><h2 id="Probabilistic-Road-Maps-Pseudocode"><a href="#Probabilistic-Road-Maps-Pseudocode" class="headerlink" title="Probabilistic Road Maps Pseudocode"></a>Probabilistic Road Maps Pseudocode</h2><p>下图是PRM过程的pseudo code，最重要的就是要实现Dist function来测量Cspace中点和点之间的距离，以及LocalPlanner function来判断某个点能否和周围的点进行连接。<br><img src="2.png" alt=""></p><h2 id="The-Dist-Function"><a href="#The-Dist-Function" class="headerlink" title="The Dist Function"></a>The Dist Function</h2><p>Dist Funcition顾名思义就是点和点之间的距离，通常有这两种算法：<br>$$<br>\begin{aligned}<br>&amp;Dist_1=\sum_i |x_i-y_i| \\<br>&amp;Dist_2=\sqrt {\sum_i (x_i-y_i)^2} \\<br>&amp;\text{其中，$x$和$y$是Cspace里的两个点。}<br>\end{aligned}<br>$$但是在很多例子中Cspace中的点代表的是转动角度，比如拥有转动关节的机械手臂，那么任意两点的角度距离就需要判断是正转近还是反转近，所有就有如下算法：<br>$$<br>Dist(\theta_1,\theta_2)=min(|\theta_1-\theta_2|,(360-|\theta_1-\theta_2|))<br>$$</p><h2 id="The-LocalPlaner-Function"><a href="#The-LocalPlaner-Function" class="headerlink" title="The LocalPlaner Function"></a>The LocalPlaner Function</h2><p>LocalPlaner是用来判断两点之间的线能否不经过障碍物连接起来，方法就是将这段直线均匀采样，再用collision check function来判断这个直线会不会经过障碍物。如下图所示的绿色点线，这条线上的绿点就是采样点，如果这些采样点中存在与障碍物的碰撞，这条线就不能连接，反之就可以连接。<br><img src="3.png" alt=""><br><img src="4.png" alt=""></p><h2 id="添加起始点和终点"><a href="#添加起始点和终点" class="headerlink" title="添加起始点和终点"></a>添加起始点和终点</h2><p>现在我们用上述方法得到了一个roadmap如下图所示：<br><img src="5.png" alt=""><br>然后用同样得方法找到起始点和终点周围得点，并用LocalPlanner判断它们能否连接起来，如果可以的话就连接起来。<br><img src="6.png" alt=""><br>最后再用Dijkstra算法找到一条路径。<br><img src="7.png" alt=""><br>这种方法得一个优点就是，一旦roadmap建立好之后，我们就能反复使用这个roadmap，只需要改变起始点和终点就可以。</p><h1 id="Sample-Based-Planners的特点"><a href="#Sample-Based-Planners的特点" class="headerlink" title="Sample Based Planners的特点"></a>Sample Based Planners的特点</h1><p>对于完备的路径算法来说，如果有路径存在它就能找到，反之则会反馈失败。但是对于PRM算法，有时即便存在路径，算法也不一定能找到，因为它是随机采样，那么采样点的多少以及位置就会影响最终的结果。考虑一下下图的情况，通过这个狭窄通道的路径是存在的，但是由于通道很小所以落在这里的点就很少，很难练成一条通路。<br><img src="8.png" alt=""><br>为了找到一条可行的路径，那么我们就要增加大量的采样点，增加了算法复杂度。而且由于样本点的随机性，产生的轨迹有时看起来很不平滑，所以通常人们会尝试一些方法让它的轨迹边缘变得平滑一些。<br><img src="9.png" alt=""><br>但是，如果该过程找不到路径，我们很难确定是确实没有路径还是说找的点不够多。因此，在实际应用中，采样点的数量是此过程的重要参数。为了解决上述问题，现在已经提出了很多能够让算法有目的的进行采样的方法，从而增加了在这些情况下找到路径的可能性。其中一种方法是在靠近障碍物附近多采样，从而构建出一条可以绕过障碍物的路径。其实应用PRM真正的优势在于它可以应用于高维的Cspace。</p><h1 id="Rapidly-Exploring-Random-Trees"><a href="#Rapidly-Exploring-Random-Trees" class="headerlink" title="Rapidly Exploring Random Trees"></a>Rapidly Exploring Random Trees</h1><p>PRM在第一阶段是在整个free space建立roadmap的，并未考虑任何一对特定的起点和终点，这种方式的优点就是可以反复使用这个roadmap对不同的起点和终点进行路径规划。但是有时候，我们可能只想要一次特定的规划，在这种情况下，在整个free space建立roadmap就很浪费时间。所以我们就提到了另一种方法，叫做Rapidly Exploring Random Trees，简称RRT，它可以用来规划特定的起始点和终点之间的路径。</p><h2 id="RRT-Procedure"><a href="#RRT-Procedure" class="headerlink" title="RRT Procedure"></a>RRT Procedure</h2><p>RRT过程就是在Cspace中建立树的过程，第一步找到起始点作为树的root，第二步随机产生一个点x在Cspace中，如果这个点在free space则找到距离它最近的一个树中的点y，第三步判断x，y之间的距离是不是大于delta，如果大于delta则说明x距离y太远，那我们就在x到y的直线上找到一个点z，让z到y的距离小于delta，否则的话就直接用x这个点，第四步用LocalPlanner function判断x或者z到y点能否进行连接，如果可以则连接，否则放弃这个点。然后重复第二步到第四步n次，最后这个以起始点为root的树就建立好了。<br><img src="10.png" alt=""><br><img src="11.png" alt=""><br><img src="12.png" alt=""></p><h2 id="RRT-2-tree-procedure"><a href="#RRT-2-tree-procedure" class="headerlink" title="RRT 2 tree procedure"></a>RRT 2 tree procedure</h2><p>RRT 2 tree就是分别将起始点和终点作为两个树的root，然后交替延展各自的树，直到两个树之间可以连接起来。<br><img src="13.png" alt=""><br><img src="14.png" alt=""><br><img src="15.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 运动规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> motion planning </tag>
            
            <tag> 运动规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运动规划二--Configuration Space</title>
      <link href="/2020/08/19/motion-plan-2/"/>
      <url>/2020/08/19/motion-plan-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以CJ Taylor老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics-motion-planning/home/welcome" target="_blank" rel="noopener">Robotics: Computational Motion Planning</a>为参考，进行归纳整理。</p></blockquote><h1 id="Configuration-Space"><a href="#Configuration-Space" class="headerlink" title="Configuration Space"></a>Configuration Space</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>上一讲中我们将motion planning问题转化到了图上，但是这样对于机器人的位置描述是离散的。然而在实际中，大多数机器人都是在空间中连续移动的，所以我们用到了Cspace。</p><h2 id="平面移动机器人"><a href="#平面移动机器人" class="headerlink" title="平面移动机器人"></a>平面移动机器人</h2><p>假设有下图所示的机器人，它可以在平面内移动到任意地方，因此这个机器人就有2个DOF，并且我们可以将这个机器人的Cspace与平面上的坐标联系起来，也就是说Cspace描述了这个机器人可以到达的位置。<br><img src="1.png" alt=""><br>当我们在平面增加了一个固定的障碍物后，我们需要在Cspace表示出来有障碍物的地方是不能到达的，如下图所示，其中黑色的部分就是障碍物的Cspace。这里我们将robot定义为一个点，然后将它的外形与obstacle结合，就有了configuration space obstacle，这样的话就可以考虑robot是一个点从而进行路径规划。所以我们发现机器人的外形也会影响它的Cspace。<br><img src="2.png" alt=""><br><img src="3.png" alt=""></p><h1 id="RR-Arm"><a href="#RR-Arm" class="headerlink" title="RR Arm"></a>RR Arm</h1><p>Cspace是可以应用到许多的机器人上，这里用一个简单的平面RR机械臂举个例子。我们可以考虑将两个手臂的转动角度$\theta_1$和$\theta_2$与Cspace联系起来。如下图所示，右图横坐标是$\theta_1$的角度，纵坐标是$\theta_2$的角度，现在没有障碍物，所以右图的Cspace整个都是free space。<br><img src="4.png" alt=""><br>当我们将障碍物加入环境中时我们就要考虑哪一种configuration是不可行的，也就是说哪一种（$\theta_1$，$\theta_2$）是会造成碰撞的。如下图所示，由于有障碍物的存在，所以有些角度的组合是不可行的。有了这样的Cspace之后，我们就可以将起始点和终点对应的（$\theta_1$，$\theta_2$）标出来，然后进行路径规划。<br><img src="5.png" alt=""></p><h1 id="Piano-Mover’s-Problem"><a href="#Piano-Mover’s-Problem" class="headerlink" title="Piano Mover’s Problem"></a>Piano Mover’s Problem</h1><p>假设有一个机器人它可以在平面内移动和旋转，所以它就有3个DOF可以表示为（$t_x$，$t_y$，$\theta$），那么它的Cspace就是3D的。如下图所示，当我们需要规划机器人穿过那个洞时，就需要考虑到它的位置和角度，就要在一个3D的Cspace上进行规划。如果是一个RRRRR Arm的话，它的Cspace就是5维的，所以不同的机器人可能会有不同维度的Cspace。<br><img src="6.png" alt=""></p><h1 id="Visibilty-Graph"><a href="#Visibilty-Graph" class="headerlink" title="Visibilty Graph"></a>Visibilty Graph</h1><p>现在我们有了Cspace，那么为了应用我们之前的算法就需要将他转换成图的形式。转化的方式就是将Cspace里顶点，包括障碍物顶点，边界的顶点，起始点和终点，如果可以连接起来并且不被障碍物阻挡那就将它们连接起来，这样就形成了一个图，就可以用dijkstra或者A*算法解决了。<br><img src="7.png" alt=""></p><h1 id="Trapezoidal-Decomposition"><a href="#Trapezoidal-Decomposition" class="headerlink" title="Trapezoidal Decomposition"></a>Trapezoidal Decomposition</h1><p>梯形分解法的目的是将Cspace的free space简化，这个方法用在configuration space obstables是多边形的情况时是十分有效的。它会将整体空间变成一张图，然后利用各区的点和边来表明相邻关系。在下图这个例子中，首先我们对obstacles的顶点的x轴坐标进行划分，将free space划分为了不同的区域。<br><img src="8.png" alt=""><br>然后我们用绿色的点来代表那些独立的free space区域，将相邻的区域连接起来，这样就形成了一个图，如绿色部分所示。然后找出哪个区域包含起始点和终点，然后就可以规划出一条路径。但是这个路径只是说明了robot可以从起始区域开始，沿着某些区域到达终点所在的区域，这并不是准确的路径规划。可能还需要进一步的规划，这个在视屏里没有介绍。<br><img src="9.png" alt=""><br><img src="10.png" alt=""></p><h1 id="Collision-Detection-and-Planning"><a href="#Collision-Detection-and-Planning" class="headerlink" title="Collision Detection and Planning"></a>Collision Detection and Planning</h1><p>这一节将介绍一种方法来判断机器人在某种configuration下会不会与障碍物发生碰撞，从而得到有障碍物的Cspace。</p><h2 id="Collision-Detection-Function"><a href="#Collision-Detection-Function" class="headerlink" title="Collision Detection Function"></a>Collision Detection Function</h2><p>为了方便理解，我们设一个function叫做CollisionCheck(x)，其中x是Cspace中的一个点。如果x是在free space的，那么CollisionCheck(x)就返回0，反之则返回1。用这个function遍历整个Cspace就可以绘制出来一个包含障碍物的Cspace。<br><img src="11.png" alt=""></p><h2 id="Collision-Detection"><a href="#Collision-Detection" class="headerlink" title="Collision Detection"></a>Collision Detection</h2><p>那么该如何实现碰撞检测呢？碰撞检测的方法如图所示，在这里我们可以使用一系列三角形来表示机器人和障碍物，这样就把机器人和障碍物是否相撞的问题转化为了三角形重叠的问题。<br><img src="12.png" alt=""><br>我们可以通过检查两个三角形的所有边，并且测试这些边中是否存在一条边使得一个三角形的所有点位于该边的一侧，另一个三角形的所有点位于该边的另一侧。我们最多需要检测两个三角形的六条边，如果找到一条边满足上述条件，那么就证明这两个三角形不重叠，反之，这两个三角形就重叠。<br><img src="13.png" alt=""><br><img src="14.png" alt=""></p><h2 id="Sampled-Points-in-freespace"><a href="#Sampled-Points-in-freespace" class="headerlink" title="Sampled Points in freespace"></a>Sampled Points in freespace</h2><p>对于连续的Cspace我们无法使用A*算法和Dijkstra算法来进行路径规划，我们可以对它进行网格化处理，也就是采样的方式。对于每一个采样点我们使用CollisionCheck函数来确定它是否是在free space，free space中的所有采样点都被视为图中的node。由于是采样，所以可能会导致free space的描述不准确，这里我们先假设相邻的node之间都是free space，于是我们就可以在这个图上进行路径规划，为了保证起始点和终点都是图中的两个节点，我们需要进行选择或者增加起始点和终点在图中。<br><img src="15.png" alt=""></p><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>这里用一个RR Arm进行举例，首先我们要根据CollisionCheck function来得到Cspace。<br><img src="16.png" alt=""><br>然后在Cspace上标出起始点和终止点，并且用Dijkstra算法进行遍历。<br><img src="17.png" alt=""><br>找到终止点后，就可以回溯一条最短路径来控制$\theta_1$和$\theta_2$到达终点了。<br><img src="18.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 运动规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> motion planning </tag>
            
            <tag> 运动规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运动规划一--图与网格的路径规划</title>
      <link href="/2020/08/09/motion-plan-1/"/>
      <url>/2020/08/09/motion-plan-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以CJ Taylor老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics-motion-planning/home/welcome" target="_blank" rel="noopener">Robotics: Computational Motion Planning</a>为参考，进行归纳整理。</p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Motion planning的目标是可以让机器人自动的决定如何从一个点移动到另一个点，这中间可能会有障碍，也可能无法到达。为了解决这个问题我们可以将地图转换成网格的形式，也可以转换成图的形式。在网格这种形式下，每一个格子都是一个node，每个node之间的cost是一样的；在图这种形式下，每个node之间cost不一定是一样的。我认为网格的形式更适合室内做motion planning，而图的形式则更适合城市交通。<br><img src="1.png" alt=""></p><h1 id="Grassfire-Algorithm"><a href="#Grassfire-Algorithm" class="headerlink" title="Grassfire Algorithm"></a>Grassfire Algorithm</h1><p>Grassfire Algorithm是应用于网格的算法，做法就像它的名字一样，从目标node开始并且将它的cost设为0，逐个访问周围的node并给它们的cost加1，直到找到开始的node，开始的node上的cost就是最小的cost，然后沿着cost从大到小就可以找到一条路线。如果经过迭代所有相邻的node都访问过了都没有找到开始的node，那么在这种情况下就没有存在的路线。<br><img src="2.png" alt=""></p><h2 id="Grassfire-algorithm-–-pseudo-code"><a href="#Grassfire-algorithm-–-pseudo-code" class="headerlink" title="Grassfire algorithm – pseudo code"></a>Grassfire algorithm – pseudo code</h2><p><img src="3.png" alt=""></p><h2 id="Grassfire-algorithm-–-Computational-Complexity"><a href="#Grassfire-algorithm-–-Computational-Complexity" class="headerlink" title="Grassfire algorithm – Computational Complexity"></a>Grassfire algorithm – Computational Complexity</h2><p>在算法迭代的过程中所有的node只会被遍历一次，所以它的计算复杂度为：<br>$$<br>\mathcal O(|V|) \text{，$V$是图中node的数量}<br>$$</p><h1 id="Dijkstra’s-Algorithm"><a href="#Dijkstra’s-Algorithm" class="headerlink" title="Dijkstra’s Algorithm"></a>Dijkstra’s Algorithm</h1><p>Grassfire Algorithm可应用于图的算法，那么它就同样也可以用于网格，只要将每个node之间的cost设为1即可。它的做法是先从起始node开始，找到他周围的所有的node，并且记下到它们的cost，接着访问cost最小的node，同样找到它周围的所有node，如果它周围的node有已经被标记的，那么就需要判断，如果从它过去cost小的话就将它原本的cost改掉，如果不是的话就保持不变，对于未标记的node就将它的cost累加即可，以此迭代直到访问目标node。在下图这个例子中，红色的node是已经被访问过的，而蓝色的node是还在被观察的node。<br><img src="4.png" alt=""></p><h2 id="Dijkstra’s-algorithm-–-pseudo-code"><a href="#Dijkstra’s-algorithm-–-pseudo-code" class="headerlink" title="Dijkstra’s algorithm – pseudo code"></a>Dijkstra’s algorithm – pseudo code</h2><p><img src="5.png" alt=""></p><h2 id="Dijkstra’s-algorithm-–-Computational-Complexity"><a href="#Dijkstra’s-algorithm-–-Computational-Complexity" class="headerlink" title="Dijkstra’s algorithm – Computational Complexity"></a>Dijkstra’s algorithm – Computational Complexity</h2><p>相比grassfire algorithm，Dijkstra’s algorithm每次迭代所选择访问的node并不是随机的，而是当前cost最小的，所以每一次迭代都会再遍历一次被观察的node，所以它的计算复杂度为：<br>$$<br>\mathcal O(|V|^2) \text{，$V$是图中node的数量}<br>$$但是，如果我们始终用priority queue来保持被观察的node是排序好的，那么它的计算复杂度变为：<br>$$<br>\mathcal O((|E|+|V|)log(|V|)) \text{，$V$是图中node的数量, $E$是edge的数量}<br>$$</p><h1 id="A-Algorithm"><a href="#A-Algorithm" class="headerlink" title="A* Algorithm"></a>A* Algorithm</h1><p>Grassfire Algorithm和Dijkstras Algorithm是一种扩散式寻找目标node的方法，几乎要遍历所有的node。这样往往是非常低效的，A*算法用到了一个H函数，这个函数的目的是可以指导算法向着目标node的方向遍历。</p><h2 id="Heuristic-Functions"><a href="#Heuristic-Functions" class="headerlink" title="Heuristic Functions"></a>Heuristic Functions</h2><p>这个H函数就相当于在原来的cost上又多加了一个新的cost，我们要利用这个cost来指导算法遍历的向着目标node的方向遍历，通常这个cost要设计为越靠近目标node，它的值越小。所以它需要满足以下要求：</p><ol><li>H(goal)要为0</li><li>对任意两个相邻node，从node x到node y都有H(x)&lt;=H(y)+d(x,y)。如果H(n)代表的是node n到goal node的距离，假设d(x,y)=1，H(x)=5，H(y)=1的话，可以发现这三个点所形成的三角形就不成立。</li></ol><p>如果满足这两点的话，对于任何node n，H(n)&lt;=从n到goal node的最短路径。</p><p>对于在网格上进行路径规划的情况，通常会用以下两种H函数：</p><ul><li>Euclidean Distance : $H(x_n,y_n)=\sqrt{((x_n-x_g)^2+(y_n-y_g)^2)}$</li><li>Euclidean Distance : $H(x_n,y_n)=|(x_n-x_g)|+|(y_n-y_g)|$</li><li>$(x_n,x_y)$是node n的坐标，$(x_g,x_g)$是目标node的坐标。<h2 id="A-algorithm-–-pseudo-code"><a href="#A-algorithm-–-pseudo-code" class="headerlink" title="A* algorithm – pseudo code"></a>A* algorithm – pseudo code</h2><img src="6.png" alt=""><h2 id="A-algorithm-和-Dijkstra’s-Algorithm对比"><a href="#A-algorithm-和-Dijkstra’s-Algorithm对比" class="headerlink" title="A* algorithm 和 Dijkstra’s Algorithm对比"></a>A* algorithm 和 Dijkstra’s Algorithm对比</h2><img src="7.png" alt=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运动规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> motion planning </tag>
            
            <tag> 运动规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四旋翼六--四旋翼的路径规划</title>
      <link href="/2020/08/02/uav-6/"/>
      <url>/2020/08/02/uav-6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以Vijay Kumar老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics-flight/home/welcome" target="_blank" rel="noopener">Robotics: Aerial Robotics</a>为参考，进行归纳整理。</p></blockquote><h1 id="变分法"><a href="#变分法" class="headerlink" title="变分法"></a>变分法</h1><p>变分法是处理泛函的数学领域，它最终寻求的是泛函的极大值或极小值。变分法的关键定理是欧拉-拉格朗日方程，它可以帮助寻找泛函的极大值或极小值，但是不能确定极大值还是极小值。在四旋翼的路径规划中，泛函数我们可以定义为四旋翼从起点到终点的路径，其中可以包括起点和终点的速度，加速度，甚至加加速度等等的规划。它的公式如下，其中$x(t)$是路径方程，$\dot x(t)$是速度方程，想要对什么进行规划就可以将它写到泛函数里面。<br><img src="1.png" alt=""><br>考虑这样一个情况，在给定了一个起点和终点，以及起始状态和最后状态以后，我们可以规划出无数种路径，但是为了找到那个最优路径，我就就需要用到欧拉-拉格朗日方程。</p><h1 id="欧拉-拉格朗日方程"><a href="#欧拉-拉格朗日方程" class="headerlink" title="欧拉-拉格朗日方程"></a>欧拉-拉格朗日方程</h1><p><img src="2.png" alt=""></p><h1 id="平滑路径（n-1）"><a href="#平滑路径（n-1）" class="headerlink" title="平滑路径（n=1）"></a>平滑路径（n=1）</h1><p>对于n=1的一阶系统，也就是说我想要一个最小的速度完成这个路径，那么它的泛函数可写为：$\mathcal L(\dot x,x,t)$。解的过程如下：<br><img src="3.png" alt=""><br>可以发现，最小速度的路径是一条直线，因为在起点，终点和时间确定的情况下最小速度完成的话肯定是直线。</p><h1 id="平滑路径（general-n）"><a href="#平滑路径（general-n）" class="headerlink" title="平滑路径（general n）"></a>平滑路径（general n）</h1><p><img src="4.png" alt=""></p><ul><li>n=1，minimum velocity (最短路径)</li><li>n=2，minimum acceleration</li><li>n=3，minimum jerk</li><li>n=4，minimum snap</li></ul><h1 id="Minimum-Jerk-Trajectory"><a href="#Minimum-Jerk-Trajectory" class="headerlink" title="Minimum Jerk Trajectory"></a>Minimum Jerk Trajectory</h1><p>jerk trajectory是3阶系统，也就是说我们需要定义起始点和终点的速度和加速度，解的过程如下：<br><img src="5.png" alt=""><br><img src="6.png" alt=""></p><h1 id="扩展到多维空间（n-1）"><a href="#扩展到多维空间（n-1）" class="headerlink" title="扩展到多维空间（n=1）"></a>扩展到多维空间（n=1）</h1><p><img src="7.png" alt=""></p><h2 id="Minimum-Jerk-for-Planar-Motions"><a href="#Minimum-Jerk-for-Planar-Motions" class="headerlink" title="Minimum Jerk for Planar Motions"></a>Minimum Jerk for Planar Motions</h2><p><img src="8.png" alt=""></p><h1 id="中间点路径规划"><a href="#中间点路径规划" class="headerlink" title="中间点路径规划"></a>中间点路径规划</h1><p><img src="9.png" alt=""><br><img src="10.png" alt=""><br>接下来我们就可以将每段用之前的方法来进行路径规划，但是不可以用一阶系统，因为这样会导致在中间点处的路径变得不可导，如下图：<br><img src="11.png" alt=""><br>下面我们将用二阶系统来进行路径规划：<br><img src="12.png" alt=""><br><img src="13.png" alt=""><br><img src="14.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Drone </tag>
            
            <tag> 四旋翼 </tag>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四旋翼五--四旋翼的控制</title>
      <link href="/2020/07/28/uav-5/"/>
      <url>/2020/07/28/uav-5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以Vijay Kumar老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics-flight/home/welcome" target="_blank" rel="noopener">Robotics: Aerial Robotics</a>为参考，进行归纳整理。</p></blockquote><h1 id="平面四旋翼的控制"><a href="#平面四旋翼的控制" class="headerlink" title="平面四旋翼的控制"></a>平面四旋翼的控制</h1><h2 id="平面四旋翼模型"><a href="#平面四旋翼模型" class="headerlink" title="平面四旋翼模型"></a>平面四旋翼模型</h2><p><img src="1.png" alt=""></p><h2 id="动态模型线性化"><a href="#动态模型线性化" class="headerlink" title="动态模型线性化"></a>动态模型线性化</h2><p>平面四旋翼的运动方程是非线性的，如下：<br>$$<br>\begin{aligned}<br>&amp;\ddot y=-\frac{u_1}{m}sin(\phi) \\<br>&amp;\ddot z=-g+\frac{u_1}{m}cos(\phi) \\<br>&amp;\ddot \phi=-\frac{u_2}{I_{xx}}<br>\end{aligned}<br>$$平面四旋翼在悬停平衡态时会有如下配置：<br>$$<br>y_0,z_0,\phi_0=0,u_{1.0}=mg,u_{2,0}=0<br>$$ 接下来我们将模型进行线性化处理。造成模型非线性的原因是模型里存在sin，cos三角函数，当$\phi \rightarrow0$时，$sin\phi \approx\phi$，$cos\phi \approx1$。并且，因为悬停状态时，$u_1$对$\ddot y$没有影响，所以将$u_1=mg$带入，最终得到如下线性模型：<br>$$<br>\begin{aligned}<br>&amp;\ddot y=-g\phi \\<br>&amp;\ddot z=-g+\frac{u_1}{m} \\<br>&amp;\ddot \phi=\frac{u_2}{I_{xx}}<br>\end{aligned}<br>$$</p><h2 id="轨迹跟踪"><a href="#轨迹跟踪" class="headerlink" title="轨迹跟踪"></a>轨迹跟踪</h2><p>平面四旋翼的轨迹设计包括了y轴和z轴的位置，速度和加速度：<br><img src="2.png" alt=""></p><h2 id="嵌套控制结构"><a href="#嵌套控制结构" class="headerlink" title="嵌套控制结构"></a>嵌套控制结构</h2><p>整个控制系统中包括了位置控制以及姿态控制，位置控制会输出四旋翼所需要的推力$u_1$以及所期望的姿态$\phi,\dot \phi$。姿态控制器得到所期望的姿态后就会输出四旋翼所需要的力矩，过程如下图：<br><img src="3.png" alt=""></p><h2 id="控制方程"><a href="#控制方程" class="headerlink" title="控制方程"></a>控制方程</h2><p><img src="4.png" alt=""></p><h1 id="3D空间四旋翼的控制"><a href="#3D空间四旋翼的控制" class="headerlink" title="3D空间四旋翼的控制"></a>3D空间四旋翼的控制</h1><h2 id="轨迹跟踪-1"><a href="#轨迹跟踪-1" class="headerlink" title="轨迹跟踪"></a>轨迹跟踪</h2><p>空间四旋翼的轨迹设计包括了x轴，y轴，z轴的位置，速度和加速度，以及yaw的角度，角速度和角加速度：<br><img src="5.png" alt=""></p><h2 id="动态模型线性化-1"><a href="#动态模型线性化-1" class="headerlink" title="动态模型线性化"></a>动态模型线性化</h2><p>空间四旋翼的运动方程是非线性的，如下：<br><img src="6.png" alt=""><br>空间四旋翼在悬停平衡态时会有如下配置：<br>$$<br>u_1\sim mg, \theta \sim 0, \phi \sim 0, \psi \sim \psi_0 \\<br>u_2\sim 0, p\sim 0, q\sim0, r\sim 0<br>$$接下来我们将模型进行线性化处理：</p><ol><li>线性动力方程<br>R是旋转矩阵，当$\theta \sim 0, \phi \sim 0, \psi \sim \psi_0$时，R经过线性化处理变成了这样：</li></ol><p>$$<br>R=\begin{bmatrix}<br>c\psi_0-\phi \theta s\psi_0 &amp; -s\psi_0 &amp; \theta c\psi_0+\phi s\psi_0 \\<br>s\psi_0+\phi \theta c\psi_0 &amp; c\psi_0 &amp; \theta s\psi_0-\phi c\psi_0 \\<br>-\theta &amp; \phi &amp; 1<br>\end{bmatrix}<br>$$并且，因为悬停状态时，$u_1$对$\ddot x, \ddot y$没有影响，所以将$u_1=mg$带入，最终得到如下线性模型：<br>$$<br>\begin{aligned}<br>&amp;\ddot r_1=\ddot x=g(\theta cos\psi+\phi sin\psi) \\<br>&amp;\ddot r_2=\ddot y=g(\theta sin\psi-\phi cos\psi) \\<br>&amp;\ddot r_3=\ddot z=\frac{-mg+u_1}{m}<br>\end{aligned}<br>$$</p><ol start="2"><li><p>角速率<br>已知角速率有如下公式：<br>$$<br>\begin{bmatrix}<br>p \\ q \\ r<br>\end{bmatrix} = \begin{bmatrix}<br>c\theta &amp;0 &amp; -c\phi s\theta \\ 0 &amp; 1 &amp; s\phi \\ s\theta &amp; 0 &amp; c\phi c\theta<br>\end{bmatrix} \begin{bmatrix}<br>\dot \phi \\ \dot \theta \\ \dot \psi<br>\end{bmatrix}<br>$$化简之后得到：<br><img src="9.png" alt=""></p></li><li><p>角动量方程<br>当$u_2\sim 0, p\sim 0, q\sim0, r\sim 0$时，力矩方程最后一项变为0，如下：<br><img src="7.png" alt=""><br><img src="10.png" alt=""></p></li></ol><h2 id="控制结构以及方程"><a href="#控制结构以及方程" class="headerlink" title="控制结构以及方程"></a>控制结构以及方程</h2><p>整个控制系统仍然包括了位置控制以及姿态控制，位置控制会输出四旋翼所需要的推力$u_1$以及所期望的姿态$\phi, \theta, \psi$。姿态控制器得到所期望的姿态后就会输出四旋翼所需要的力矩，过程如下图：<br><img src="8.png" alt=""></p><p>$\color{red}{这里留一个问题，在控制方程中p_c=q_c=0，r_c=\dot \psi^{des}，但是我不知道为什么}$</p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Drone </tag>
            
            <tag> 四旋翼 </tag>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四旋翼四--四旋翼动力学</title>
      <link href="/2020/07/25/uav-4/"/>
      <url>/2020/07/25/uav-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以Vijay Kumar老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics-flight/home/welcome" target="_blank" rel="noopener">Robotics: Aerial Robotics</a>为参考，进行归纳整理。</p></blockquote><h1 id="方程式"><a href="#方程式" class="headerlink" title="方程式"></a>方程式</h1><p><img src="1.png" alt=""></p><h1 id="Euler’s公式"><a href="#Euler’s公式" class="headerlink" title="Euler’s公式"></a>Euler’s公式</h1><p>有一个刚体B，它的主轴为$\mathbf b_1$，$\mathbf b_2$，$\mathbf b_3$，它分别沿各个主轴旋转的角速度为$w_1$，$w_2$，$w_3$，那么它的合角速度为：$^A\mathbf w^B=w_1\mathbf b_1+w_2\mathbf b_2+w_3\mathbf b_3$。$^A\mathbf H_c$是刚体在inertial frame下的角动量，那么我们就可以得到合力矩 $\mathbf M_c=\frac{^Ad\mathbf H_c}{dt}$。但是，对于无人机来说，IMU得到的角速度都是在body frame下的，我们可以从以下公式得到合力矩，其中p，q，r就是从IMU得到的角速度：<br>$$<br>\begin{aligned}<br>&amp;\frac{^Bd\mathbf H_c}{dt}=I_{11}\dot {w_1}\mathbf b_1+I_{22}\dot {w_2}\mathbf b_2+I_{33}\dot {w_3}\mathbf b_3 \\<br>&amp;\frac{^Bd\mathbf H_c}{dt}+^A\mathbf w^B\times \mathbf H_c=\mathbf M_c<br>\end{aligned}<br>$$<img src="6.png" alt=""></p><h1 id="四旋翼移动方程"><a href="#四旋翼移动方程" class="headerlink" title="四旋翼移动方程"></a>四旋翼移动方程</h1><p>以下公式是在inertial frame下沿着各个轴所受的力：<br><img src="7.png" alt=""><br>以下公式是在body frame下沿着各个轴所受的力矩：<br><img src="8.png" alt=""><br>以下的两个公式是用来将body frame下的IMU得到的角速度转换到inertial frame下的roll，pitch，yaw角速度，反之亦然。这两个角速度不一样是因为，当UAV有一定的roll或pitch角度时，再转动yaw的时候，就会有分量是沿着roll或pitch的，但是对于UAV的自身坐标系来说，只有r在变。<br><img src="9.png" alt=""></p><h2 id="平面四旋翼模型"><a href="#平面四旋翼模型" class="headerlink" title="平面四旋翼模型"></a>平面四旋翼模型</h2><p><img src="10.png" alt=""></p><h2 id="四旋翼的状态空间"><a href="#四旋翼的状态空间" class="headerlink" title="四旋翼的状态空间"></a>四旋翼的状态空间</h2><p>$q$描述的是系统配置，$x$描述的是系统状态；$q_e$描述的是平衡状态下的系统配置，$x_e$描述的是平衡状态下的系统状态：<br><img src="11.png" alt=""></p><h1 id="补充资料"><a href="#补充资料" class="headerlink" title="补充资料"></a>补充资料</h1><p><strong>质心</strong>，假如有如下粒子系统，它的质心为：$\mathbf r_c=\frac{1}{m}\sum_{i=1}^Nm_i\mathbf p_i$。<br><img src="5.png" alt=""><br><strong>转动惯量</strong>：用来描述物体转动的难易程度。假如有如下不规则刚体，那么它沿某一固定轴旋转的转动惯量为：$I=\sum m_iy_i^2$<br><img src="2.png" alt=""><br>对于下图所示的系统，它的转动惯量就是：$I=mr^2$。刚体的<strong>力矩</strong> $M=I\alpha$，$\alpha$是角加速度。<br><img src="3.png" alt=""><br>下图所示的系统中，当小球被施加F力后开始转动，小球的力矩为$M =r\times F$，动量为$P=F\cdot t=ma\cdot t=mv$，角动量为$H=r\times P=I\cdot w$，$w$是角速度。<br><img src="4.png" alt=""><br><strong>角动量守恒</strong>：当物体外力矩$\tau$为0时，角动量守恒，证明过程如下：<br>$$<br>\left.<br>\begin{array}{l}<br>\Delta P=F\cdot \Delta t \\<br>M = r\times F<br>\end{array}<br>\right\}<br>\Rightarrow M = r\times \frac{\Delta P}{\Delta t} \\<br>\because \Delta H = r\times \Delta P \Rightarrow\frac{\Delta H}{\Delta t}=r\times \frac{\Delta P}{\Delta t} \\<br>\therefore M = \frac{\Delta H}{\Delta t}<br>$$<br>所以力矩是角动量的变化率。角动量时F力累计出来的，力矩是F力瞬间的作用。</p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Drone </tag>
            
            <tag> 四旋翼 </tag>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四旋翼三--四旋翼运动学</title>
      <link href="/2020/07/24/uav-3/"/>
      <url>/2020/07/24/uav-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以Vijay Kumar老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics-flight/home/welcome" target="_blank" rel="noopener">Robotics: Aerial Robotics</a>为参考，进行归纳整理。</p></blockquote><p>关于旋转矩阵，欧拉角这部分内容可以看我之前的文章，这里做一些补充说明。</p><h1 id="旋转矩阵的性质"><a href="#旋转矩阵的性质" class="headerlink" title="旋转矩阵的性质"></a>旋转矩阵的性质</h1><ul><li>正交矩阵，即$RR^T=RR^{-1}=I$</li><li>行列式等于+1</li><li>任意两个旋转矩阵相乘依然是旋转矩阵</li><li>旋转矩阵的逆矩阵仍然是旋转矩阵</li></ul><h1 id="沿任意向量旋转的旋转矩阵"><a href="#沿任意向量旋转的旋转矩阵" class="headerlink" title="沿任意向量旋转的旋转矩阵"></a>沿任意向量旋转的旋转矩阵</h1><h2 id="叉乘转换"><a href="#叉乘转换" class="headerlink" title="叉乘转换"></a>叉乘转换</h2><p>两个向量叉乘可以写成一个矩阵和一个向量点乘的形式，如下：<br>$$<br>\begin{bmatrix}<br>a_1 \\ a_2 \\ a_3<br>\end{bmatrix} \times \begin{bmatrix}<br>b_1 \\ b_2 \\ b_3<br>\end{bmatrix} = \begin{bmatrix}<br>a_2b_3-a_3b_2 \\ a_3b_1-a_1b_3 \\ -a_2b_1+a_1b_2<br>\end{bmatrix} = \begin{bmatrix}<br>0&amp;-a_3&amp;a_2 \\ a_3&amp;0&amp;-a_1 \\ -a_2&amp;a_1&amp;0<br>\end{bmatrix}\begin{bmatrix}<br>b_1 \\ b_2 \\ b_3<br>\end{bmatrix}<br>$$为了以示区别，将那个展开的矩阵写为$\hat a$，所有就有了：<br>$$<br>\vec a \times \vec b = \hat a \vec b<br>$$</p><h2 id="沿任意向量旋转"><a href="#沿任意向量旋转" class="headerlink" title="沿任意向量旋转"></a>沿任意向量旋转</h2><p>沿任意向量旋转的旋转矩阵如下，其中$u$是旋转轴，$\phi$是旋转角度。<br>$$<br>Rot(u,\phi) = Icos\phi+uu^T(1-cos\phi)+\hat usin\phi<br>$$</p><h1 id="旋转以及角速度"><a href="#旋转以及角速度" class="headerlink" title="旋转以及角速度"></a>旋转以及角速度</h1><h2 id="旋转矩阵的导数"><a href="#旋转矩阵的导数" class="headerlink" title="旋转矩阵的导数"></a>旋转矩阵的导数</h2><p>已知有一个旋转矩阵$R(t)$，因为它是正交矩阵所以有：<br>$$<br>R^T(t)R(t)=I \\<br>R(t)R(t)^T=I<br>$$<br>对它进行求导后得到：<br>$$<br>\dot R^TR+R^T\dot R=0 \\<br>R\dot R^T+\dot RR^T=0<br>$$其中$R^T\dot R$和$\dot RR^T$是斜对称矩阵，所以它们就可以转换为一个向量叉乘的形式。</p><h2 id="旋转的角速度"><a href="#旋转的角速度" class="headerlink" title="旋转的角速度"></a>旋转的角速度</h2><p>假设刚体上有一点$p$经过旋转之后变成了点$q$，那么它们俩之间的关系可以写成$q(t)=R(t)p$，对两边同时求导就得到了$\dot q=\dot Rp$，其中$p$是在body frame下的位置，$\dot q$是在inertial frame下的速度。经过转换我们可以得到以下两个式子：<br>$$<br>\begin{aligned}<br>&amp;R^T\dot q=R^T\dot Rp \\<br>&amp;\dot q=\dot RR^Tq<br>\end{aligned}<br>$$在第一个式子中，点$p$左乘$R^T\dot R$后就得到了它在body frame下的速度，因此可以将$R^T\dot R$看作一个角速度记为$\hat w^b$，用来得到在body frame下某个点的速度。在第二个式子中，点$q$左乘$\dot RR^T$后就得到了它在inertial frame下的速度，因此可以将$\dot RR^T$看作一个角速度记为$\hat w^s$，用来得到在inertial frame下某个点的速度。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>如下图，点$p=[1,0,0]^T$绕z轴旋转到点$q=[0,1,0]^T$，求出在inertial frame和body frame的速度。<br><img src="1.png" alt=""><br>首先我们算出$\hat w^b$和$\hat w^s$如下：<br><img src="2.png" alt=""><br>在转动的过程中$q$点的坐标为$[cos\theta, sin\theta,0]^T$，可以得到在inertial frame的速度为：<br>$$<br>\begin{aligned}<br>\dot q&amp;=\dot RR^Tq \\<br>&amp;=\begin{bmatrix}<br>-sin\theta \\ cos\theta \\ 0<br>\end{bmatrix}\dot \theta<br>\end{aligned}<br>$$而在body frame里，因为刚体自身坐标系会随着刚体转动，所以点$p$的速度方向相当于点$q$在$\theta=0$时的方向，通过计算也可以得到答案：<br>$$<br>\begin{aligned}<br>R^T\dot q &amp;=R^T\dot Rp \\<br>&amp;=\begin{bmatrix}<br>0 \\ 1 \\0<br>\end{bmatrix} \dot \theta<br>\end{aligned}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Drone </tag>
            
            <tag> 四旋翼 </tag>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四旋翼二--系统设计</title>
      <link href="/2020/07/19/uav-2/"/>
      <url>/2020/07/19/uav-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以Vijay Kumar老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics-flight/home/welcome" target="_blank" rel="noopener">Robotics: Aerial Robotics</a>为参考，进行归纳整理。</p></blockquote><h1 id="基础力学结构"><a href="#基础力学结构" class="headerlink" title="基础力学结构"></a>基础力学结构</h1><h2 id="电机物理性质"><a href="#电机物理性质" class="headerlink" title="电机物理性质"></a>电机物理性质</h2><p>$\tau$与$w$的关系是电机本身的特性，当$\tau$到达与drag相交的那个点时，电机的转速达到最大，那么这个转速$w_0$对应的$F$就至少要大于等于1/4mg才能使飞机克服重力飞起来。阻力drag包括了电机的反电磁阻力和空气阻力等，并且它阻力大小与桨叶也有关。<br><img src="1.png" alt=""></p><h2 id="基础力学（悬停）"><a href="#基础力学（悬停）" class="headerlink" title="基础力学（悬停）"></a>基础力学（悬停）</h2><p>受力分析如下图所示，$\mathbf {a_1}$，$\mathbf  {a_2}$，$\mathbf  {a_3}$为inertial frame，$\mathbf  {b_1}$，$\mathbf  {b_2}$，$\mathbf  {b_3}$为body frame，$F$是电机产生的推力，$M$是电机产生的反力矩。<br><img src="2.png" alt=""><br>合外力为：<br>$$<br>\mathbf F=\mathbf F_1+\mathbf  F_2+\mathbf  F_3+\mathbf  F_4-mg\mathbf  a_3<br>$$<br>合力矩包括电机带动螺旋桨所产生的反力矩，这是yaw力矩，以及电机产生的向上的升力所产生的roll，pitch力矩。<br>$$<br>\mathbf M= \mathbf r_1\times \mathbf F_1 + \mathbf r_2\times \mathbf F_2 + \mathbf r_2\times \mathbf F_2 + \mathbf r_3\times \mathbf F_3 + \mathbf r_4\times \mathbf F_4 \\ + \mathbf M_1 + \mathbf M_2 + \mathbf M_3 + \mathbf M_4<br>$$</p><h2 id="垂直方向加减速"><a href="#垂直方向加减速" class="headerlink" title="垂直方向加减速"></a>垂直方向加减速</h2><p><img src="3.png" alt=""></p><h1 id="动力学和一维线性控制"><a href="#动力学和一维线性控制" class="headerlink" title="动力学和一维线性控制"></a>动力学和一维线性控制</h1><p>假设有一个UAV只可以上下移动，那么该如何控制它呢？<br><img src="4.png" alt=""></p><h2 id="高度控制"><a href="#高度控制" class="headerlink" title="高度控制"></a>高度控制</h2><p>垂直方向加减速方程式为：<br>$$<br>\sum_{i=1}^4 k_Fw_i^2+m\mathbf g=m\mathbf a \\<br>\mathbf a=\frac{d^2x}{dt^2}=\ddot x<br>$$<br>将加速度$\mathbf a$设为输入$u$，那么$u=\ddot x$，这是一个二阶系统，系统方程可写为：<br>$$<br>u=\frac {1}{m}[\sum_{i=1}^4 k_Fw_i^2+m\mathbf g]<br>$$</p><h2 id="控制一个二阶线性系统"><a href="#控制一个二阶线性系统" class="headerlink" title="控制一个二阶线性系统"></a>控制一个二阶线性系统</h2><ol><li>问题：<br>状态，输入：$x,u\in \mathbb R$<br>系统模型：$\ddot x=u$<br>想要$x$跟随设计的线路$x^{des}(t)$</li><li>方法：<br>定义误差$e(t)=x^{des}(t)-x(t)$<br>想要$e(t)$收敛到0</li><li>策略：<br>从下式中得到$u$:<br>$$<br>\begin{aligned}<br>&amp;\ddot e+K_v\dot e+K_pe=0 \qquad K_p,K_v&gt;0 \\<br>&amp;(PD控制)u(t)=\ddot x^{dex}(t)+K_v\dot e(t)+K_pe(t) \\<br>&amp;(PID控制)u(t)=\ddot x^{dex}(t)+K_v\dot e(t)+K_pe(t)+K_i\int_0^t e(\tau) d\tau<br>\end{aligned}<br>$$<br>在有干扰（比如风）以及系统建模的时候有错误时（比如有的质量不知道）就经常会用PID控制。</li></ol><h1 id="设计考量"><a href="#设计考量" class="headerlink" title="设计考量"></a>设计考量</h1><p>在系统设计时我们需要考虑到系统的限制，比如最大推力，最大加速度，功率限制等等。那么，在有最大推力限制的情况下，系统控制方程如下所示：<br><img src="5.png" alt=""></p><h1 id="机动性"><a href="#机动性" class="headerlink" title="机动性"></a>机动性</h1><p>判断四旋翼的机动性有两个方面，一方面是在一定的初速度下能够停下来的距离越短机动性越好，另一方面是在某一速度下飞行的四旋翼转弯的曲率越小机动性越好。第一种情况如下图所示，需要注意的是为了有最大的减速度，要将大部分推力用于减速，因此四旋翼的高度会掉下来。<br><img src="6.png" alt=""><br>第二种情况如下图所示，要尽量减小$\rho$：<br><img src="7.png" alt=""></p><h2 id="四旋翼在平面的受力分析"><a href="#四旋翼在平面的受力分析" class="headerlink" title="四旋翼在平面的受力分析"></a>四旋翼在平面的受力分析</h2><p>推力$u_1$和转矩$u_2$是系统的两个控制量。<br><img src="8.png" alt=""></p><h1 id="通信结构"><a href="#通信结构" class="headerlink" title="通信结构"></a>通信结构</h1><p><img src="9.png" alt=""></p><h1 id="尺寸的影响"><a href="#尺寸的影响" class="headerlink" title="尺寸的影响"></a>尺寸的影响</h1><p>四旋翼的简易结构如下图所示，通常有$r\approx \frac{1}{2}l$，所以有$r\sim l$。<br><img src="10.png" alt=""></p><ol><li>质量，转动惯量<br>物体的质量与体积有关，所以得到$m\sim l^3$，转动惯量$I$又等于$ml^2$，所以推得$I\sim l^5$</li><li>推力<br>$$<br>\begin{aligned}<br>&amp;F\sim \pi r^2\times(wr)^2=\pi r^2v^2 \\<br>&amp;\Rightarrow F \sim l^2v^2 \\<br>&amp;\because a \sim \frac{F}{m}，m\sim l^3 \\<br>&amp; \therefore a \sim \frac{v^2}{l}<br>\end{aligned}<br>$$</li><li>力矩<br>$$<br>\begin{aligned}<br>&amp;M\sim Fl \Rightarrow M \sim l^3v^2 \\<br>&amp;\because \alpha \sim \frac{M}{I}，I\sim l^5 \\<br>&amp;\therefore \alpha \sim \frac {v^2}{l^2}<br>\end{aligned}<br>$$</li></ol><h2 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h2><p>经过实验得出了速度$v$与四旋翼大小$l$之间的关系有两种，无论是哪一种关系，都有这个结论，越小的四旋翼机动性越高。</p><ol><li>Froude scaling<br>这个结论更适用于小型的四旋翼：<br>$$<br>\begin{aligned}<br>&amp;v\sim \sqrt{l}，F\sim l^3 \\<br>&amp;\Rightarrow  a\sim 1， \alpha \sim \frac{1}{l}<br>\end{aligned}<br>$$</li><li>Mach scaling<br>$$<br>\begin{aligned}<br>&amp;v\sim 1，F\sim l^2 \\<br>&amp;\Rightarrow  a\sim \frac{1}{l}， \alpha \sim \frac{1}{l^2}<br>\end{aligned}<br>$$</li></ol>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Drone </tag>
            
            <tag> 四旋翼 </tag>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四旋翼一--介绍</title>
      <link href="/2020/07/19/uav-1/"/>
      <url>/2020/07/19/uav-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以Vijay Kumar老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics-flight/home/welcome" target="_blank" rel="noopener">Robotics: Aerial Robotics</a>为参考，进行归纳整理。</p></blockquote><h1 id="四旋翼的结构"><a href="#四旋翼的结构" class="headerlink" title="四旋翼的结构"></a>四旋翼的结构</h1><p>四旋翼的结构如下图所示：<br><img src="1.png" alt=""><br>每个电机相对的那个电机旋转方向是相同的，而相邻的电机旋转方向是相反的，这样是为了抵消电机所产生的反力矩。通过控制四个电机的速度就可以控制UAV的位置和方向。</p><h1 id="自动化飞行的重要部分"><a href="#自动化飞行的重要部分" class="headerlink" title="自动化飞行的重要部分"></a>自动化飞行的重要部分</h1><p>在任何系统中，为了实现自动化控制，需要知道以下四个部分该如何实现：</p><ol><li>状态估计 – 估计UAV的位置和速度（包括旋转速度和角速度）</li><li>控制 – 控制电机并且正确的执行从而得到所期望的状态。</li><li>地图 – 有能力绘制周围环境的地图</li><li>规划 – 可以计算规划一个路径</li></ol><p>在室外我们可以使用GPS来定位并且导航，但是在室内就需要用到SLAM（Simultaneous Localization And Mapping）来定位并且绘制地图。如下图，如果机器人可以估计$d_1$，$d_2$，$d_3$，$d_1’$，$d_2’$，$d_3’$和$\Delta x$，那么就可以应用SLAM。<br><img src="2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Drone </tag>
            
            <tag> 四旋翼 </tag>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四元数</title>
      <link href="/2020/06/27/quaternion/"/>
      <url>/2020/06/27/quaternion/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：Krasjet的<a href="quaternion.pdf">四元数与三维旋转</a></p></blockquote><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>四元数可以写为如下形式：<br>$$<br>q=a+bi+cj+dk\quad (a,b,c,d\in \mathbb R)<br>$$其中：<br>$$<br>    i^2=j^2=k^2=ijk=-1<br>$$上面的公式就决定了四元数一切性质，四元数的定义和复数非常类似，唯一的区别就是四元数一共有三个虚部 $(i,j,k)$，而复数只有一个。</p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="模长"><a href="#模长" class="headerlink" title="模长"></a>模长</h2><p>一个四元数 $q=a+bi+cj+dk$ 的模长为：<br>$$<br>||q||=\sqrt{a^2+b^2+c^2+d^2}<br>$$如果用标量向量有序对的形式进行表示的话，$q=[s,\mathbf v]$ 的模长为：<br>$$<br>\begin{aligned}<br>||q||&amp;=\sqrt{s^2+||\mathbf v||^2} \\<br>&amp;=\sqrt{s^2+\mathbf v\cdot\mathbf v} \qquad (\mathbf v\cdot\mathbf v=||\mathbf v||^2)<br>\end{aligned}<br>$$</p><h2 id="四元数加法和减法"><a href="#四元数加法和减法" class="headerlink" title="四元数加法和减法"></a>四元数加法和减法</h2><p>与复数类似，四元数的加法只需要将分量相加就可以了。如果我们有两个四元数$q_1=a+bi+cj+dk$，$q_2=e+fi+gj+hk$，那么它们的和为：<br>$$<br>\begin{aligned}<br>q_1+q_2&amp;=a+bi+cj+dk+e+fi+gj+hk \\<br>&amp;=(a+e)+(b+f)i+(c+g)j+(d+h)k<br>\end{aligned}<br>$$减法也是同理：<br>$$<br>q_1-q_2=(a-e)+(b-f)i+(c-g)j+(d-h)k<br>$$如果四元数是以标量向量有序对形式定义的，比如说 $q_1=[s,\mathbf v]$，$q_2=[t,\mathbf u]$，那么：<br>$$<br>q_1\pm q_2=[s\pm t, \mathbf v\pm \mathbf u]<br>$$</p><h2 id="标量乘法"><a href="#标量乘法" class="headerlink" title="标量乘法"></a>标量乘法</h2><p>如果我们有一个四元数$q = a + bi + cj + dk$ 和一个标量$s$，那么它们的乘积为：<br>$$<br>\begin{aligned}<br>sq &amp;= s(a + bi + cj + dk)\\<br>&amp;= sa + sbi + scj + sdk)<br>\end{aligned}<br>$$四元数与标量的乘法是遵守交换律的，也就是说$sq=qs$。</p><h2 id="四元数乘法"><a href="#四元数乘法" class="headerlink" title="四元数乘法"></a>四元数乘法</h2><p>四元数之间的乘法比较特殊，它们是不遵守交换律的，也就是说一般情况下$q_1q_2 \neq q_2q_1$。除了交换律之外，我们经常使用的结合律和分配律在四元数内都是成立的。那么，如果有两个四元数$q_1 = a + bi + cj + dk$和$q_2 = e + f i + gj + hk$，那么它们的乘积为：<br>$$<br>\begin{aligned}<br>q_1q_2&amp;=(a + bi + cj + dk)(e + f i + gj + hk) \\<br>&amp;= ae + a f i + agj + ahk+\\<br>&amp;\quad bei + b f i2 + bgij + bhik+ \\<br>&amp;\quad cej + c f ji + cgj2 + chjk+ \\<br>&amp;\quad dek + d f ki + dgkj + dhk2<br>\end{aligned}<br>$$再根据下图的表格（表格中有颜色的格子代表着乘法交换律不成立）：<br><img src="1.png" alt=""><br>我们就能进一步简化四元数乘积的结果，于是就有了如下定理：对任意四元数 $q_1=[s,\mathbf v]$, $q_2=[t,\mathbf u]$，$q_1q_2$ 的结果是：<br>$$<br>q_1q_2=[st-\mathbf v\cdot\mathbf u,s\mathbf u+t\mathbf v+\mathbf v \times\mathbf u]<br>$$</p><h2 id="纯四元数"><a href="#纯四元数" class="headerlink" title="纯四元数"></a>纯四元数</h2><p>如果一个四元数能写成这样的形式：<br>$$<br>v=[0,\mathbf v]<br>$$那么我们称$v$是一个<strong>纯四元数</strong>，即仅有虚部的四元数。</p><h2 id="四元数的逆和共轭"><a href="#四元数的逆和共轭" class="headerlink" title="四元数的逆和共轭"></a>四元数的逆和共轭</h2><p>一个四元数 $q = a + bi + cj + dk$ 的<strong>共轭</strong>为 $q^\ast = a - bi - cj - dk$ 。如果用标量向量有序对的形式来定义的话，$q = [s,\mathbf v]$ 的共轭为$q^\ast = [s,−\mathbf v]$ 。共轭四元数的一个非常有用的性质就是：<br>$$<br>\begin{aligned}<br>qq^\ast&amp;=[s,\mathbf v]\cdot[s,−\mathbf v] \\<br>&amp;=[s^2+\mathbf v\cdot \mathbf v,0] \\<br>&amp;= s^2+x^2+y^2+z^2 \\<br>&amp;= ||q||^2<br>\end{aligned}<br>$$可以看到最终结果是一个实数，并且它是四元数模长的平方，而且满足 $qq^\ast=q^\ast q$。</p><p>我们定义$q^{-1}$是$q$的<strong>逆</strong>，并且有:<br>$$<br>\begin{aligned}<br>qq^{-1}&amp;=q^{-1}q=1 \qquad (q\neq0) \\<br>q^{-1}&amp;=\frac {q^*}{||q||^2}<br>\end{aligned}<br>$$</p><h1 id="四元数与3D旋转"><a href="#四元数与3D旋转" class="headerlink" title="四元数与3D旋转"></a>四元数与3D旋转</h1><p>定理：3D旋转公式（四元数型，正交情况）<br>当$\mathbf v_\bot$ 正交于旋转轴 $\mathbf u$ 时，旋转 $\theta$ 角度之后的 $\mathbf v_\bot’$ 可以使用四元数乘法来获得。令$v_\bot= [0, \mathbf v_\bot]$ ，$q = [cos(\theta), sin(\theta)\mathbf u]$，那么：<br>$$<br>v_\bot’=qv_\bot<br>$$</p><p>定理：3D旋转公式（四元数型，平行情况）<br>当$\mathbf v_{||}$ 平行于旋转轴 $\mathbf u$ 时，旋转 $\theta$ 角度之后的 $\mathbf v_{||}’$ 用四元数可以写为：<br>$$<br>v_{||}’=v_{||}<br>$$</p><p>定理：3D旋转公式（四元数型，一般情况）<br>任意向量$\mathbf v$沿着以单位向量定义的旋转轴$\mathbf u$旋转$\theta$度之后的$\mathbf v’$可以使用四元数乘法来获得。令$v=[0,\mathbf v]$，$q = [\frac{1}{2}cos(\theta), \frac{1}{2}sin(\theta)\mathbf u]$，那么：<br>$$<br>v’=qvq^*=qvq^{-1}<br>$$</p><p>定理：3D 旋转公式（矩阵型）<br>任意向量$\mathbf v$沿着以单位向量定义的旋转轴$\mathbf u$旋转$\theta$度之后的$\mathbf v’$可以使用矩阵乘法来获得。令 $a=cos(\frac{1}{2}\theta)$，$b=sin(\frac{1}{2}\theta)u_x$，$c=sin(\frac{1}{2}\theta)u_y$，$a=d=sin(\frac{1}{2}\theta)u_z$，那么：<br>$$<br>v’=<br>\begin{bmatrix}<br>1-2c^2-2d^2&amp;2bc-2ad&amp;2ac + 2bd \\<br>2bc + 2ad&amp;1-2b^2-2d^2&amp;2cd-2ab \\<br>2bd-2ac&amp;2ab+2cd&amp;1-2b^2-2c^2<br>\end{bmatrix} v<br>$$</p><h1 id="四元数，欧拉角和旋转矩阵的转换"><a href="#四元数，欧拉角和旋转矩阵的转换" class="headerlink" title="四元数，欧拉角和旋转矩阵的转换"></a>四元数，欧拉角和旋转矩阵的转换</h1><p>根据上一章我们知道四元数本身就代表了一种旋转，这一章我们将了解它和旋转矩阵以及欧拉角之间的关系。</p><h2 id="四元数转旋转矩阵"><a href="#四元数转旋转矩阵" class="headerlink" title="四元数转旋转矩阵"></a>四元数转旋转矩阵</h2><p>已知四元数 $q=(q_0,q_1,q_2,q_3)$ ，那么旋转矩阵为：<br>$$<br>R=\begin{bmatrix}<br>q_0^2+q_1^2-q_2^2-q_3^2 &amp; 2(q_1q_2-q_0q_3) &amp; 2(q_1q_3+q_0q_2) \\<br>2(q_1q_2+q_0q_3) &amp; q_0^2-q_1^2+q_2^2-q_3^2 &amp; 2(q_2q_3-q_0q_1) \\<br>2(q_1q_3-q_0q_2) &amp; 2(q_2q_3+q_0q_1) &amp;q_0^2-q_1^2-q_2^2+q_3^2<br>\end{bmatrix}<br>$$</p><h2 id="旋转矩阵转四元数"><a href="#旋转矩阵转四元数" class="headerlink" title="旋转矩阵转四元数"></a>旋转矩阵转四元数</h2><p>已知旋转矩阵：<br>$$<br>R=\begin{bmatrix}<br>r_{11}&amp;r_{12}&amp;r_{13} \\<br>r_{21}&amp;r_{22}&amp;r_{23} \\<br>r_{31}&amp;r_{32}&amp;r_{33}<br>\end{bmatrix}<br>$$那么求解四元数的方法可以从以下公式中得到：<br>$$<br>r_{11}+r_{22}+r_{33}=2q_0^2-1\Rightarrow q_0=\pm \frac{1}{2} \sqrt{1+r_{11}+r_{22}+r_{33}} \\<br>r_{11}-r_{22}-r_{33}=2q_1^2-1\Rightarrow q_1=\pm \frac{1}{2} \sqrt{1+r_{11}-r_{22}-r_{33}} \\<br>r_{22}-r_{11}-r_{33}=2q_2^2-1\Rightarrow q_2=\pm \frac{1}{2} \sqrt{1+r_{22}-r_{11}-r_{33}} \\<br>r_{33}-r_{11}-r_{22}=2q_3^2-1\Rightarrow q_3=\pm \frac{1}{2} \sqrt{1+r_{33}-r_{11}-r_{22}}<br>$$从这里我们可以得到好几组解，于是又有了如下限制：<br>$$<br>r_{12}+r_{21}=2(q_1q_2-q_0q_3)+2(q_1q_2+q_0q_3)=4q_1q_2 \\<br>r_{21}-r_{12}=2(q_1q_2+q_0q_3)-2(q_1q_2-q_0q_3)=4q_0q_3 \\<br>r_{13}+r_{31}=2(q_1q_3+q_0q_2)+2(q_1q_3-q_0q_2)=4q_1q_3 \\<br>r_{13}-r_{31}=2(q_1q_3+q_0q_2)-2(q_1q_3-q_0q_2)=4q_0q_2 \\<br>r_{23}+r_{32}=2(q_2q_3-q_0q_1)+2(q_2q_3+q_0q_1)=4q_2q_3 \\<br>r_{32}-r_{23}=2(q_2q_3+q_0q_1)-2(q_2q_3-q_0q_1)=4q_0q_1<br>$$这样只要得到$q_0$到$q_3$中的任意一个就能求出其他的值，假设我们先求$q_0$的值，则有：<br>$$<br>q_0=\pm \frac{1}{2} \sqrt{1+r_{11}+r_{22}+r_{33}} \\<br>q_1=\frac{r_{32}-r{23}}{4q_0} \\<br>q_2=\frac{r_{13}-r{31}}{4q_0} \\<br>q_3=\frac{r_{21}-r{12}}{4q_0}<br>$$从上式中可以看到，求得的四元数有两个，但是他们表示的是同一种旋转关系（一种是沿着$\mathbf u$转$\theta$角，另一种是沿着$-\mathbf u$转$-\theta$角）。至于先求$q_0$到$q_3$中的哪个值，在实际使用时应该全部一起求，看哪个值大，就选取哪个，以防止某一项在出现0时无法计算的情况。</p><h2 id="欧拉角转四元数"><a href="#欧拉角转四元数" class="headerlink" title="欧拉角转四元数"></a>欧拉角转四元数</h2><p>已知欧拉角：$\alpha$、$\beta$、$\gamma$，四元数为：<br>$$<br>q=\begin{bmatrix}<br>cos\frac{\gamma}{2} \\<br>0 \\<br>0 \\<br>sin\frac{\gamma}{2}<br>\end{bmatrix}<br>\begin{bmatrix}<br>cos\frac{\beta}{2} \\<br>0 \\<br>sin\frac{\beta}{2} \\<br>0<br>\end{bmatrix}<br>\begin{bmatrix}<br>cos\frac{\alpha}{2} \\<br>sin\frac{\alpha}{2} \\<br>0 \\<br>0<br>\end{bmatrix}=\begin{bmatrix}<br>cos\frac{\alpha}{2}cos\frac{\beta}{2}cos\frac{\gamma}{2}+sin\frac{\alpha}{2}sin\frac{\beta}{2}sin\frac{\gamma}{2} \\<br>sin\frac{\alpha}{2}cos\frac{\beta}{2}cos\frac{\gamma}{2}-cos\frac{\alpha}{2}sin\frac{\beta}{2}sin\frac{\gamma}{2} \\<br>cos\frac{\alpha}{2}sin\frac{\beta}{2}cos\frac{\gamma}{2}+sin\frac{\alpha}{2}cos\frac{\beta}{2}sin\frac{\gamma}{2} \\<br>cos\frac{\alpha}{2}cos\frac{\beta}{2}sin\frac{\gamma}{2}-sin\frac{\alpha}{2}sin\frac{\beta}{2}cos\frac{\gamma}{2}<br>\end{bmatrix}<br>$$</p><h2 id="四元数转欧拉角"><a href="#四元数转欧拉角" class="headerlink" title="四元数转欧拉角"></a>四元数转欧拉角</h2><p>已知四元数 $q=(q_0,q_1,q_2,q_3)$ ，那么欧拉角为：<br>$$<br>\begin{bmatrix}<br>\alpha \\<br>\beta \\<br>\gamma<br>\end{bmatrix}=<br>\begin{bmatrix}<br>atan2(2(q_0q_1+q_2q_3),1-2(q_1^2+q_2^2)) \\<br>arcsin(2(q_0q_2-q_1q_3)) \\<br>atan2(2(q_0q_3+q_1q_2),1-2(q_2^2+q_3^2))<br>\end{bmatrix}<br>$$但是当$\beta$角度为$\pm90$度时，四元数反向计算欧拉角时会出现奇点，是无法计算的。也就是出现了万向锁问题，这时候我们通常令$\alpha=0$，然后解出欧拉角的值。</p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四元数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波器计算无人机姿态</title>
      <link href="/2020/06/24/kalman-filter-imu-sensor-fusion/"/>
      <url>/2020/06/24/kalman-filter-imu-sensor-fusion/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：<a href="https://d1.amobbs.com/bbs_upload782111/files_50/ourdev_711905ORLKPP.pdf" target="_blank" rel="noopener">基于陀螺仪及加速度计信号融合的姿态角度测量</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇介绍卡尔曼滤波器的文章中说到，对于无人机的姿态计算，我们不能单独的用陀螺仪或者是加速度计来进行测量，而是需要将它们俩进行融合，那么这一讲我们就来看看如何用卡尔曼滤波器进行滤波融合。</p><h1 id="卡尔曼滤波融合过程"><a href="#卡尔曼滤波融合过程" class="headerlink" title="卡尔曼滤波融合过程"></a>卡尔曼滤波融合过程</h1><p>首先建立系统的状态方程和测量方程：<br><img src="1.png" alt=""><br>式中，$\varphi$是系统的真实角度，$b$是陀螺仪的零点偏移量，$\omega_{gyro}$为包含固定偏差的陀螺仪输出角速度，$\varphi_{acce}$为加速度计经处理后得到的角度值，$w_g$为陀螺仪测量噪声，$w_a$为加速度计测量噪声，$w_g$和$w_a$相互独立，此处假设二者为满足正态分布的白色噪声，令$T_s$为系统采样周期，得到离散系统的状态方程和测量方程：<br><img src="2.png" alt=""><br>并且系统过程噪声协方差矩阵$Q$以及测量误差的协方差矩阵$R$为：<br><img src="3.png" alt=""><br>式中，q_acce和q_gyro分别是加速度计和陀螺仪测量的协方差，其数值代表卡尔曼滤波器对其传感器数据的信任程度，值越小，表明信任程度越高。在该系统中陀螺仪的值更为接近准确值，因此取q_gyro的值小于q_acce的值。</p><p>此时，对应上一篇所介绍的卡尔曼滤波器的计算过程，我们现在已经知道了矩阵$A=\begin{bmatrix}1&amp;-T_s\\0&amp;1\end{bmatrix}$， 矩阵$B=\begin{bmatrix}T_s\\0\end{bmatrix}$，接下来我们只要给定一个初始化的系统状态$\hat x_0$以及它的方差$P_0$，还有干扰的协方差$Q$和$R$就可以带入公式计算了，具体计算过程请参考上一篇。下图是参考资料里用到的初始化参数，可以做一个参考：<br><img src="4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kalman Filter </tag>
            
            <tag> 卡尔曼滤波器 </tag>
            
            <tag> sensor fusion </tag>
            
            <tag> 无人机姿态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波器</title>
      <link href="/2020/06/21/kalman-filter/"/>
      <url>/2020/06/21/kalman-filter/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：Matlab video：<a href="https://www.mathworks.com/videos/understanding-kalman-filters-part-1-why-use-kalman-filters--1485813028675.html" target="_blank" rel="noopener">Understanding Kalman Filters</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了测量无人机的姿态，我们会用到一种传感器叫做IMU（Inertial Measurement Unit），它其中就包括了测量角速度的陀螺仪（Gyroscope）和测量角度的加速度计（accelerometer）。</p><p>但是，陀螺仪输出的是角速度，要通过积分才能获得角度，但是即使在零输入状态时，陀螺仪仍是有输出的，它的输出是白噪声和慢变随机函数的叠加，受此影响，在积分的过程中，必然会引进累计误差，积分时间越长，误差就越大。这时候，便需要加速度传感器的加入，利用加速度传感器来对陀螺仪进行校正。由于加速度传感器可以利用力的分解原理，通过重力加速度在不同轴向上的分量来判断倾角。同时，它没有积分误差，所以加速度传感器在相对静止的条件下，可以有效校正陀螺仪的误差。但在运动状态下，加速度传感器输出的可信度就要下降，因为它测量的是重力和外力的合力。</p><p>所以，为了准确的得到无人机的姿态，就需要将陀螺仪和加速度计的数据进行融合。最常用的就是卡尔曼滤波器（Kalman Filter），简称KF。</p><h1 id="卡尔曼滤波器的适用范围"><a href="#卡尔曼滤波器的适用范围" class="headerlink" title="卡尔曼滤波器的适用范围"></a>卡尔曼滤波器的适用范围</h1><p>为什么要使用卡尔曼滤波器呢？首先，它可以用于估算无法被直接测量的系统。举例来说，我们如何监控火箭发动机内部的温度呢？因为火箭发动机内部的温度非常高，传感器放进去就会被融化掉，所以只能把传感器放在发动机的外侧，这时就可以使用卡尔曼滤波器来估算内部的温度，从而间接得到我们想要的信息。<br><img src="1.png" alt=""><br>第二种情况就是在数据源有噪音干扰时，我们可以用KF来估计系统的状态。举例来说，我们如何准确的得出汽车行驶距离呢？首先车上有三种sensor，IMU，里程表和GPS。因为IMU会产生累计误差，里程表会受到路况的影响，而GPS的信号有时会被物体遮挡，这时我们就可以用KF将这三个测量值结合，最后得到汽车最优的估算位置。<br><img src="2.png" alt=""></p><h1 id="状态观察器"><a href="#状态观察器" class="headerlink" title="状态观察器"></a>状态观察器</h1><p>在了解KF之前，我们先了解一下什么是状态观察器（State Observers）。举一个例子，你不知道你的好朋友Timmy心情怎么样，你可以给她一个好吃的然后就可以通过她的表情来判断，所以状态观察可以帮助你估计你无法直接或测量的东西。我们接着刚才测量火箭发动机内部温度的例子来说，首先我们要给火箭发动机建立一个数学模型，因为给发动机的燃料量是已知的，将这个燃料量输入到数学模型中就可以得到一个估算的外部温度$\hat T_{ext}$以及一个估算的内部温度$\hat T_{in}$，于此同时我们也可以测出真实的火箭发动机外部的温度$T_{ext}$。但是在现实中，因为外界干扰以及传感器自身误差，测量值$T_{ext}$和理想值$\hat T_{ext}$肯定是不一样的。<br><img src="3.png" alt=""><br>因此我们的目的是让$T_{ext}$和$\hat T_{ext}$一致，这样的话$T_{in}$和$\hat T_{in}$就也是一样的。我们需要将$T_{ext}$和$\hat T_{ext}$的差值作为error反馈到数学模型中，于是问题就变成了如何选择控制器增益K使$T_{ext}$和$\hat T_{ext}$的误差最小化。<br><img src="4.png" alt=""><br>将模型写成数学表达式，如下图：<br><img src="5.png" alt=""></p><h1 id="最优状态估计器"><a href="#最优状态估计器" class="headerlink" title="最优状态估计器"></a>最优状态估计器</h1><p>从上一节介绍的状态观察器我们知道，在理想情况下只要数学模型通过修正后就可以使误差收敛到0，但是在现实情况中，实际物体会受到环境的干扰而且传感器还有测量误差，这就导致我们得到的$y_k$是有干扰的。所以，为了更加准确的表达实际物体的模型，需要给测量值加上测量误差$v_k$以及给物体加上环境干扰误差$w_k$，如下图：<br><img src="6.png" alt=""><br>$v$是均值为0，协方差为R的高斯分布：$v\sim N(0,R)$，$w$是均值为0，协方差为Q的高斯分布：$w\sim N(0,Q)$。</p><p>假设我们这个状态观察器是用来描述汽车行驶距离的，$x$代表的是汽车实际位置，$y$代表的是汽车的测量位置。首先我们可以通过数学模型计算出汽车在$\hat x_{k-1}$的位置，但由于汽车会受到环境的干扰，那么汽车的实际位置就可能是在$\hat x_{k-1}$附近，可以用一个概率分布图来表示。然后在下一个时刻汽车的实际位置就会在$\hat x_k$附近，并且概率分布的方差会比上一个时刻大，因为误差会累积。与此同时，传感器也会给我们一个测量值$y_k$，由于这个值也是有误差的，所以汽车的实际位置同样也可以用概率分布图来表示。现在我们就有了估算位置概率分布$\hat x_k$以及测量位置概率分布$y_k$，将这个两个概率函数相乘就得到了另一个概率函数，这个函数的均值就是最优估计值。<br><img src="7.png" alt=""></p><h1 id="卡尔曼滤波器"><a href="#卡尔曼滤波器" class="headerlink" title="卡尔曼滤波器"></a>卡尔曼滤波器</h1><p>卡尔曼滤波器其实就是最优状态估计器的一种，是不过它取最有估计值时并不是简单的将两个概率函数相乘，我们先看一下卡尔曼滤波器的方程式：<br>$$<br>\hat x_k=A\hat x_{k-1}+Bu_k+K_k(y_k-C(A\hat x_{k-1}+Bu_k))<br>$$<br>是不是感觉很熟悉，其实它就是下图所示的蓝色区域：<br><img src="8.png" alt=""><br>为了得到最优估计值$\hat x_k$，首先我们要得到根据数学模型得到的预测值$\hat x_k^-=A\hat x_{k-1}+Bu_k$，这个预测值是用上一时刻的最优估计值计算得出的，于是KF就可以进一步写为：<br>$$<br>\hat x_k=\hat x_k^-+K_k(y_k-C(\hat x_k^-))<br>$$<br>我们可以将KF的计算分为两个部分，第一部分是根据数学模型得到的预测值$\hat x_k^-$，第二部分是通过反馈对预测值进一步更新，最后就得到了最优估计值。</p><p>现在唯一的问题就是反馈增益$K_k$该如何决定。对于KF来说，它是动态的对$K_k$进行更改，当上一时刻得出的最优值更靠近预测值时，那么这一时刻它就更相信预测值，反之亦然。接下来我们来看KF的计算过程，首先是根据上一时刻系统的状态通过数学模型进行预测：<br>$$<br>\begin{aligned}<br>&amp;\hat x_k^-=A\hat x_{k-1}+Bu_k \\<br>&amp;P_k^- = AP_{k-1}A^T+Q<br>\end{aligned}<br>$$<br>$P_k^-$是$\hat x_k^-$的协方差，因此通过这一步我们就得到了预估状态的概率分布函数。接下来就要更新增益$K_k$，然后计算出最优估计值$\hat x_k$以及它的方差$P_k$：<br>$$<br>\begin{aligned}<br>&amp;K_k=\frac {P_k^-C^T}{CP_k^-C^T+R} \\<br>&amp;\hat x_k = \hat x_k^-+K_k(y_k-C\hat x_k^-) \\<br>&amp;P_k=(1-K_kC)P_k^-<br>\end{aligned}<br>$$<br><img src="9.png" alt=""><br>在这里我们讨论一下$K_k$的取值，当$P_k^-$等于0时，也就是说预测值$\hat x_k^-$的方差为0，所以它是100%可以被相信的，此时$K_k$等于0，最后就可以得到$\hat x_k=\hat x_k^-$，最优估计值就是预测值。反之，当$R$等于0时，也就是说测量值的方差为0，那么测量值就是100%可以被相信的，此时$K_k$等于$C^{-1}$，最后就可以得到$\hat x_k=y_k$。</p><p>KF也可以被用来做传感器融合，接着上述例子，为了增加测量的准确性，我们给车子又增加了传感器IMU，这时测量值就会变成一个2x1的向量，计算过程如下图：<br><img src="10.png" alt=""></p><p>将KF简单总结一下，首先它会通过一种方式将预测值和测量值进行融合，然后将这个结果作为这个时刻的最优解，然后判断这个最优解越靠近谁，在下个时刻就会给谁更多的权重就越相信谁。</p><h1 id="扩展卡尔曼滤波器"><a href="#扩展卡尔曼滤波器" class="headerlink" title="扩展卡尔曼滤波器"></a>扩展卡尔曼滤波器</h1><p>卡尔曼滤波器可以为线性系统提供最优的估计值，但是对于非线性系统则不适用。对于非线性系统，我们需要将系统近似转化为线性系统后再进行计算，这个就是扩展卡尔曼滤波器（Extended Kalman Filter，即EKF）。当系统是非线性时，系统状态方程则写为如下形式：<br>$$<br>\begin{aligned}<br>&amp;x_k=f(x_{k-1},u_k)+w_k \\<br>&amp;y_k=g(x_k)+v_k<br>\end{aligned}<br>$$<br>其中$f(x_{k-1},u_k)$和$g(x_k)$都是非线性函数。</p><p>接下来我们需要求出方程$f$和$g$的Jacobian矩阵，也就是它们对$x$的偏导数：<br>$$<br>\begin{aligned}<br>&amp;F=\frac {\partial f}{\partial x}|_{\hat x_{k-1},u_k} \\<br>&amp;G=\frac {\partial g}{\partial x}|_{\hat x_k}<br>\end{aligned}<br>$$<br>被线性化处理的系统就变成了这样:<br>$$<br>\begin{aligned}<br>&amp;\Delta x_k \approx F\Delta x_{k-1}+w_k \\<br>&amp;\Delta y_k \approx G\Delta x_k+v_k<br>\end{aligned}<br>$$<br>接下来计算EKF的过程就和KF一样了，先是进行预测：<br>$$<br>\begin{aligned}<br>&amp;\hat x_k^-=f(\hat x_{k-1},u_k) \\<br>&amp;P_k^- = FP_{k-1}F^T+Q<br>\end{aligned}<br>$$<br>然后再更新：<br>$$<br>\begin{aligned}<br>&amp;K_k=\frac {P_k^-G^T}{GP_k^-G^T+R} \\<br>&amp;\hat x_k = \hat x_k^-+K_k(y_k-g(\hat x_k^-)) \\<br>&amp;P_k=(1-K_kG)P_k^-<br>\end{aligned}<br>$$<br><img src="11.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kalman Filter </tag>
            
            <tag> 卡尔曼滤波器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂八--Jacobian Matrix</title>
      <link href="/2020/05/24/robot-arm-jacobian-matrix/"/>
      <url>/2020/05/24/robot-arm-jacobian-matrix/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料<a href="https://nrsyed.com/2017/12/10/inverse-kinematics-using-the-jacobian-inverse-part-2/" target="_blank" rel="noopener">Inverse kinematics using the Jacobian inverse</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前几讲我们所介绍的例子中，我们用到的都是用解析法来准确的求解IK问题，而这一讲中，我们将介绍一种数值法求解IK的方法，叫做<strong>Jacobian Matrix</strong>。用这种方法，我们不需要计算复杂的方程式，只要知道了手臂的结构，就可以通过不断迭代的方式来逼近我们的目标点。</p><h1 id="Jacobian-Matrix"><a href="#Jacobian-Matrix" class="headerlink" title="Jacobian Matrix"></a>Jacobian Matrix</h1><p>首先我们看Jacobian Matrix是什么样的,其中n是手臂joint的数量，x，y，z是手臂末端点的坐标位置：<br>$$<br>J=\begin{bmatrix}<br>\frac{\partial x}{\partial \theta_1}&amp;\frac{\partial x}{\partial \theta_2}&amp;\cdots&amp;\frac{\partial x}{\partial \theta_n} \\<br>\frac{\partial y}{\partial \theta_1}&amp;\frac{\partial y}{\partial \theta_2}&amp;\cdots&amp;\frac{\partial y}{\partial \theta_n} \\<br>\frac{\partial z}{\partial \theta_1}&amp;\frac{\partial z}{\partial \theta_2}&amp;\cdots&amp;\frac{\partial z}{\partial \theta_n} \\<br>\end{bmatrix}<br>$$</p><h2 id="Jacobian-Matrix的意义"><a href="#Jacobian-Matrix的意义" class="headerlink" title="Jacobian Matrix的意义"></a>Jacobian Matrix的意义</h2><p>我们发现Jacobian Matrix的每一列其实就是将手臂末端点坐标位置对每一个joint求偏导数。换句话说，Jacobian Matrix每一列的意义就是这个joint的变化对手臂末端点位置的影响或者说是变化率。举例来说，第一列指的就是joint 1发生的变化会对手臂末端点产生什么样的影响。然后我们将每个joint对手臂末端点的影响列在一个矩阵里，这个矩阵就是Jacobian Matrix。</p><p>我们知道对$y=f(x)$的函数求导，就会得到这个函数在各个x点处的斜率。当x变化很小时，我们就可以通过这个斜率来估算y的变化，可以写为$\Delta y=f’(x)\Delta x$。而Jacobian Matrix充当的就是这里$f’(x)$的角色，于是就有了如下关系：$\Delta r=J\Delta \theta$<br>$$<br>\begin{aligned}<br>&amp;\Delta r&amp;=\begin{bmatrix}<br>\Delta x \\<br>\Delta y \\<br>\Delta z<br>\end{bmatrix} &amp;=\begin{bmatrix}<br>\frac{\partial x}{\partial \theta_1}&amp;\frac{\partial x}{\partial \theta_2}&amp;\cdots&amp;\frac{\partial x}{\partial \theta_n} \\<br>\frac{\partial y}{\partial \theta_1}&amp;\frac{\partial y}{\partial \theta_2}&amp;\cdots&amp;\frac{\partial y}{\partial \theta_n} \\<br>\frac{\partial z}{\partial \theta_1}&amp;\frac{\partial z}{\partial \theta_2}&amp;\cdots&amp;\frac{\partial z}{\partial \theta_n} \\<br>\end{bmatrix}\begin{bmatrix}<br>\Delta \theta_1 \\<br>\Delta \theta_2 \\<br>\vdots \\<br>\Delta \theta_n \\<br>\end{bmatrix}\\<br>&amp;&amp;&amp;=\begin{bmatrix}<br>\frac{\partial x}{\partial \theta_1}\Delta \theta_1+\frac{\partial x}{\partial \theta_2}\Delta \theta_2+\cdots+\frac{\partial x}{\partial \theta_n}\Delta \theta_n \\<br>\frac{\partial y}{\partial \theta_1}\Delta \theta_1+\frac{\partial y}{\partial \theta_2}\Delta \theta_2+\cdots+\frac{\partial y}{\partial \theta_n}\Delta \theta_n \\<br>\frac{\partial z}{\partial \theta_1}\Delta \theta_1+\frac{\partial z}{\partial \theta_2}\Delta \theta_2+\cdots+\frac{\partial z}{\partial \theta_n}\Delta \theta_n<br>\end{bmatrix}\\<br>\end{aligned}<br>$$<br>通过这个等式，我们将每个joint对手臂末端点位置的影响都累加起来，就得到了最终x，y，z的变化量。</p><p>但是这个过程只解决了顺向运动学的问题，那么IK问题怎么解决呢？很简单，首先定义手臂末端需要移动的方向和大小$\Delta r$，然后在等式两边左乘Jacobian Matrix的逆矩阵，这样就得到了每个joint的变化量$\Delta \theta=J^{-1}\Delta r$。$J^{-1}$就相当于$\Delta r$对$\Delta \theta$的变化率，当$\Delta r$是指向目标点的向量时，就可以计算出到达目标点所需要的$\Delta \theta$，但是这个等式只有在$\Delta r$比较小的时候才能近似成立，所以我们需要一步一步的迭代，慢慢移动到目标点。然而，在绝大多数情况下Jacobian Matrix都是不可逆的，因此会用到pseudoinverse：$J^+=J^T(JJ^T)^{-1}$</p><h2 id="Jacobian-Matrix的建立"><a href="#Jacobian-Matrix的建立" class="headerlink" title="Jacobian Matrix的建立"></a>Jacobian Matrix的建立</h2><p>在了解了Jacobian Matrix的定义以及意义后，我们接下来看如何得到Jacobian Matrix。以一个平面3轴的手臂为例：<br><img src="1.png" alt=""><br>上面第一幅图中，如果只有手臂的第一个joint动，而其他的joint都不动的话，手臂末端点的运动轨迹就是那段弧形虚线，而那段切线就是当前手臂末端点对joint 1的偏导数，也就对应了我们Jacobian Matrix的第一列，以此类推。所以Jacobian Matrix就是这些切线的集合。</p><p>那我们该如何得到那条切线的向量呢？首先我们定义$r_e$是基坐标指向手臂末端点的向量，$r_j$是基坐标指向joint j的向量，$z_j$是joint j的旋转向量，那么$r_e-r_j$就是图中的黑色箭头。因为每一个joint所对应的那条切线永远都是垂直于$r_e-r_j$和$z_j$的，所以就可以用叉乘的方式得到那条切线的向量：$z_j\times(r_e-r_j)$，因此就可以写出我们的Jacobian Matrix：<br>$$<br>J=\begin{bmatrix}<br>(z_1\times(r_e-r_1))^T&amp;(z_2\times(r_e-r_2))^T&amp;\dots&amp;(z_n\times(r_e-r_n))^T<br>\end{bmatrix}<br>$$</p><p>在就得到了Jacobian Matrix后，就可以用它来解决IK问题了。其实，Jacobian Matrix提供了一种线性趋近的方式，当手臂的joint发生改变时Jacobian Matrix也发生改变。当$\Delta r$比较小时，这个方法就能比较准确的驱动手臂末端以直线移动到目标点，但是需要更多的迭代运算。当$\Delta r$比较大时，手臂末端就能更快的移动到目标点，但是移动过程中就不一定完全按照所期望的那条直线移动。因此，$\Delta r$大小也可以用来控制移动速度，但是这个速度与时间无关。</p><p>其实，手臂的控制不单单只有位置还有方向，为了将手臂末端的方向控制考虑进来，我们需要增加新的限制条件，首先要在$\Delta r$中增加手臂末端绕x，y，z轴旋转的转速，然后再在Jacobian Matrix中添加每个joint的转轴，最后可写为如下形式：<br>$$<br>\begin{aligned}<br>\Delta r&amp;=\left[\begin{array}{ccc|ccc}<br>\Delta x&amp;\Delta y &amp;\Delta z &amp;w_x &amp;w_y&amp; w_z<br>\end{array}\right]^T \\<br>J&amp;=\begin{bmatrix}<br>(z_1\times(r_e-r_1))^T&amp;(z_2\times(r_e-r_2))^T&amp;\dots&amp;(z_n\times(r_e-r_n))^T \\<br>\hline<br>z_1&amp;z_2&amp;\dots&amp;z_n<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><h2 id="Jacobian-Matrix的补充"><a href="#Jacobian-Matrix的补充" class="headerlink" title="Jacobian Matrix的补充"></a>Jacobian Matrix的补充</h2><p>最后，关于Jacobian Matrix的建立还有最后一点注意事项，上述我们介绍的都是手臂的joint是旋转的情况，然而手臂的joint还有可能是线性运动的情况，不同类型的joint在建立Jacobian Matrix时也不一样，区别如下：</p><table><thead><tr><th align="center"></th><th align="center">Prismatic</th><th align="center">Revolute</th></tr></thead><tbody><tr><td align="center">$\begin{bmatrix}\Delta x&amp;\Delta y&amp;\Delta z\end{bmatrix}^T$</td><td align="center">$z_j$</td><td align="center">$z_j\times(r_e-r_j)$</td></tr><tr><td align="center">$\begin{bmatrix}w_x&amp;w_y&amp;w_z\end{bmatrix}^T$</td><td align="center">$\begin{bmatrix}0&amp;0&amp;0\end{bmatrix}^T$</td><td align="center">$z_j$</td></tr></tbody></table><h2 id="如何用Jacobian-Matrix计算每个电机的Torque"><a href="#如何用Jacobian-Matrix计算每个电机的Torque" class="headerlink" title="如何用Jacobian Matrix计算每个电机的Torque"></a>如何用Jacobian Matrix计算每个电机的Torque</h2><p>当我们将Jacobian Matrix转置就得到了如下Matrix：<br>$$<br>J^T=\begin{bmatrix}<br>\frac{\partial x}{\partial \theta_1}&amp;\frac{\partial y}{\partial \theta_1}&amp;\frac{\partial z}{\partial \theta_1} \\<br>\frac{\partial x}{\partial \theta_2}&amp;\frac{\partial y}{\partial \theta_2}&amp;\frac{\partial z}{\partial \theta_2} \\<br>\vdots&amp;\vdots&amp;\vdots \\<br>\frac{\partial x}{\partial \theta_n}&amp;\frac{\partial y}{\partial \theta_n}&amp;\frac{\partial z}{\partial \theta_n} \\<br>\end{bmatrix}<br>$$转置后的Jacobian Matrix每一行就变成了手臂末端点的那条黑色切线，当我们在手臂末端点施加一个力$F=[F_x,F_y,F_z]^T$时，这个$F$力对于每一个joint的torque就是沿着黑色切线方向的力乘以距离，由于这条黑色切线在叉积时已经包含了距离信息，所以直接用这条黑色切线点乘$F$即可：<br>$$<br>\tau=\begin{bmatrix}<br>\tau_1\\<br>\tau_2\\<br>\vdots\\<br>\tau_n\\<br>\end{bmatrix}<br>=\begin{bmatrix}<br>\frac{\partial x}{\partial \theta_1}&amp;\frac{\partial y}{\partial \theta_1}&amp;\frac{\partial z}{\partial \theta_1} \\<br>\frac{\partial x}{\partial \theta_2}&amp;\frac{\partial y}{\partial \theta_2}&amp;\frac{\partial z}{\partial \theta_2} \\<br>\vdots&amp;\vdots&amp;\vdots \\<br>\frac{\partial x}{\partial \theta_n}&amp;\frac{\partial y}{\partial \theta_n}&amp;\frac{\partial z}{\partial \theta_n} \\<br>\end{bmatrix}\begin{bmatrix}<br>F_x\\<br>F_y\\<br>F_z\\<br>\end{bmatrix}<br>$$当然用这个方法计算每个joint的torque时我们忽略了手臂自身的重量，由于手臂自身重量对于每个joint的影响随着手臂的形态的变化而不断变化，所以先暂时不考虑。</p>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jacobian Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂七--轨迹规划实例</title>
      <link href="/2020/05/14/robot-arm-7/"/>
      <url>/2020/05/14/robot-arm-7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="任务概述"><a href="#任务概述" class="headerlink" title="任务概述"></a>任务概述</h1><p>机械手臂需要夹住放在桌子上的杯子，然后将杯子挂到墙上的杯架，位置参数以及手臂的DH参数如下图：<br><img src="1.png" alt=""><br><img src="2.png" alt=""></p><h1 id="条件设定"><a href="#条件设定" class="headerlink" title="条件设定"></a>条件设定</h1><ol><li>我们需要规划手臂将杯子从桌子上拿起然后放到杯架上的整个轨迹。为了让轨迹变得顺滑，我们可以先让手臂拿起杯子一小段距离到$f_{c_1}$，然后到达杯架前，调整到适当姿态，然后将杯子平移到杯架上，如下图所示：<br><img src="3.png" alt=""></li><li>我们要定义杯子在各点（$P_{0-f}$）的时间、坐标位置以及姿态。<br><img src="4.png" alt=""><br><img src="5.png" alt=""></li><li>我们就可以求出杯子在各点处相对于世界坐标的Transformation Matrix （$^0_CT$）<br><img src="6.png" alt=""></li><li>再推导出手臂末端点在各点处相对于世界坐标的Transformation Matrix （$^0_6T$）<br><img src="7.png" alt=""></li><li>从$^0_6T$得知$^0P_{6org}$在各点的位置和姿态。<br><img src="8.png" alt=""></li></ol><h1 id="以linear-function-with-parabolic-blends在Cartesian-space下规划轨迹"><a href="#以linear-function-with-parabolic-blends在Cartesian-space下规划轨迹" class="headerlink" title="以linear function with parabolic blends在Cartesian-space下规划轨迹"></a>以linear function with parabolic blends在Cartesian-space下规划轨迹</h1><ol><li>求出$^0P_{6org}$在各DOF（$X,Y,Z,\Phi_X,\Phi_Y,\Phi_Z$）每段的速度和加速度<br><img src="9.png" alt=""></li><li>建立并绘出各DOF在每个时间区段的轨迹<br><img src="10.png" alt=""></li><li>此时轨迹规划已经完成，接下来就要用IK计算出轨迹上所有设定点以及轨迹内插点的六轴转角（计算量很大）。以第二个via point为例：<br><img src="11.png" alt=""><br><img src="12.png" alt=""><br><img src="13.png" alt=""><br><img src="14.png" alt=""><br><img src="15.png" alt=""> <blockquote><p>note: 当有多个解时，可以将它带入Transformation Matrix里来验证哪一组解是正确的。</p></blockquote></li><li>将解出的轨迹设定点以及轨迹内插点的六轴转角对各自的时间进行画图：<br><img src="16.png" alt=""> </li><li>将转角带入FK，画出杯子的坐标及姿态，已确认轨迹规划的正确性，同样以第二个via point为例：<br><img src="17.png" alt=""></li></ol><h1 id="以linear-function-with-parabolic-blends在joint-space下规划轨迹"><a href="#以linear-function-with-parabolic-blends在joint-space下规划轨迹" class="headerlink" title="以linear function with parabolic blends在joint-space下规划轨迹"></a>以linear function with parabolic blends在joint-space下规划轨迹</h1><ol><li>以IK先计算出各点的六轴转角<br><img src="18.png" alt=""></li><li>求出各轴（$\theta_1-\theta_6$）在每个时段的速度及加速度<br><img src="19.png" alt=""></li><li>建立各轴在每个时段的轨迹<br><img src="20.png" alt=""></li><li>以FK画出杯子对事件的轨迹，确认轨迹有通过设定点。<br><img src="21.png" alt=""></li><li>在Cartensian-space下和在joint-space下轨迹比较。<br><img src="22.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械手臂轨迹规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂六--线性与二次方程搭配的轨迹规划曲线</title>
      <link href="/2020/05/13/robot-arm-6/"/>
      <url>/2020/05/13/robot-arm-6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>上一讲中我们介绍了一种用三次多项式的方式来规划轨迹曲线的方式，但是在很多实际任务中我们需要用到直线轨迹。但是如果单纯的使用直线轨迹，那么在两段之间的中间点处速度是不连续的，为了解决这个问题，我们把直线两端修改为二次方程式，从而让速度变得平滑，如下图：<br><img src="1.png" alt=""></p><h1 id="规划方式"><a href="#规划方式" class="headerlink" title="规划方式"></a>规划方式</h1><p>规划的方式分为两段，直线段和二次多项式段：</p><ul><li>Linear段，是匀速的：<br>$$<br>\dot \theta=\frac{\theta_h-\theta_b}{t_h-t_b}=\dot \theta_{t_b}<br>$$</li><li>Parabolic段，是等加速的：<br>$$<br>\begin{aligned}<br>&amp;\theta(t)=\theta_0+\dot \theta_0t+\frac{1}{2}\color{red}{\ddot \theta}t^2 （这个是等加速度的位移公式）\\<br>&amp;\dot \theta(t)=\dot \theta_0+\color{red}{\ddot \theta}t \\<br>&amp;\dot \theta(t_b)=\color{red}{\ddot \theta}t_b（assume \space \dot \theta_0=0） \\<br>\end{aligned}<br>$$<br><img src="2.png" alt=""><br>因为直线段和二次多项式段的交界处的速度需要一样，所以可以得到如下结论：<br><img src="3.png" alt=""></li></ul><h2 id="对加速度-ddot-theta-的讨论"><a href="#对加速度-ddot-theta-的讨论" class="headerlink" title="对加速度$\ddot \theta$的讨论"></a>对加速度$\ddot \theta$的讨论</h2><p><img src="4.png" alt=""></p><h2 id="三种方式的比较"><a href="#三种方式的比较" class="headerlink" title="三种方式的比较"></a>三种方式的比较</h2><p><img src="5.png" alt=""></p><h1 id="多段Linear-Function-with-Parabolic-Blends"><a href="#多段Linear-Function-with-Parabolic-Blends" class="headerlink" title="多段Linear Function with Parabolic Blends"></a>多段Linear Function with Parabolic Blends</h1><p>假设，有一个路径规划，其中有n个中间点，然后用Linear Function with Parabolic Blends的方法将各个点串起来，但是实际的轨迹并没有经过中间点（黑色实线），如下图所示：<br><img src="6.png" alt=""></p><ul><li>轨迹中间线段$[\theta_i \space \theta_{i+1}]$的计算方式：<br><img src="7.png" alt=""></li><li>轨迹第一段的计算方法：<br>前面我们说过实际的轨迹并没有经过中间点，但是起始位置是必须要经过的，所以我们不能用计算中间线段的方式来计算起始点。这里假设起始位置速度为0，然后我们可以在$\theta_0$的后面插入一个假设的中间点$\theta_1$，并且它的位置是二次多项式所需时间$t_1$的一半（$t_{\theta_1}=\frac{1}{2}t_1$）。然后用以下方式计算：<br><img src="8.png" alt=""></li><li>轨迹最后一段的计算方法：<br>最后一段和第一段一样，假设最后速度为0，在$\theta_f$点前插入一个假设的中间点$\theta_n$，并且它的位置是二次多项式所需时间$t_n$的一半（$t_{\theta_n}=\frac{1}{2}t_n$）。然后用以下方式计算：<br><img src="9.png" alt=""></li></ul><h2 id="举例：一个RRR手臂"><a href="#举例：一个RRR手臂" class="headerlink" title="举例：一个RRR手臂"></a>举例：一个RRR手臂</h2><p><img src="10.png" alt=""><br><img src="11.png" alt=""><br><img src="12.png" alt=""><br><img src="13.png" alt=""></p><h1 id="多段Linear-Function-with-Parabolic-Blends的讨论"><a href="#多段Linear-Function-with-Parabolic-Blends的讨论" class="headerlink" title="多段Linear Function with Parabolic Blends的讨论"></a>多段Linear Function with Parabolic Blends的讨论</h1><ol><li>在真实系统中可以达到的加速度$\ddot \theta$取决于很多因素：<ul><li>电机的规格</li><li>手臂的姿态：手臂在不同状态下，各个joint所需要承受的torque不同。</li><li>手臂的动作状态：手臂在不同运行状态下，各个joint所需要承受的惯性力不同。</li></ul></li><li>路径规划没有通过中间点的解决方法：在原本的via points两边插入pseudo via points（橘色的点），让原本的via points落在linear段上，这样就会通过，如下图：<br><img src="14.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械手臂线性轨迹规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂五--轨迹规划</title>
      <link href="/2020/05/13/robot-arm-5/"/>
      <url>/2020/05/13/robot-arm-5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>机械手臂的轨迹规划就是说当手臂执行某一个操作时，比如说，从一个位置取某一物件然后移动到另一个位置，这段运动轨迹就需要我们来规划，规划的内容就包括位置、速度以及加速度随时间的变化。通常我们理想的轨迹都是平滑的曲线，其中包括起始点{$T_{initial}$}，很多的中间点{$T_{t_i}$}以及终点{$T_{final}$}。如果轨迹变化很大的话，那么在变化的那个点就需要手臂有很大的torque来改变运动状态，有时手臂可能做不到，而且会让整个运动过程看起来不流畅。<br><img src="1.png" alt=""></p><h1 id="轨迹规划"><a href="#轨迹规划" class="headerlink" title="轨迹规划"></a>轨迹规划</h1><p>轨迹的规划方式有两种，一种是在joint-space下进行，一种是在Cartesian-space下进行。接下来将分别介绍两种方法，以及它们的优缺点。</p><h2 id="Joint-space下的轨迹规划"><a href="#Joint-space下的轨迹规划" class="headerlink" title="Joint-space下的轨迹规划"></a>Joint-space下的轨迹规划</h2><p>在Joint-space下规划轨迹的方法如下：</p><ol><li>定义这段轨迹在空间中的起始点{$T_{initial}$}，中间点{$T_{t_i}$}以及终点{$T_{final}$}。</li><li>计算这些点的IK，得到在每个时间点$t_i$，手臂的每个joint所对应的角度。</li><li>对每一个joint都在其自己的角度坐标系下规划一条平滑的曲线。</li><li>计算FK，检查手臂末端点在Cartesian-space下轨迹的可行性（可能会碰到障碍物）。</li></ol><p>具体过程如下图：<br><img src="2.png" alt=""></p><blockquote><p>Note：<br>优点：计算量小，只需要计算起始点、中间点和终点的IK。<br>缺点：在空间中的运动轨迹不直观。</p></blockquote><h2 id="Cartesian-space下的轨迹规划"><a href="#Cartesian-space下的轨迹规划" class="headerlink" title="Cartesian-space下的轨迹规划"></a>Cartesian-space下的轨迹规划</h2><p>在Cartesian-space下规划轨迹的方法如下：</p><ol><li>定义这段轨迹在空间中的起始点{$T_{initial}$}，中间点{$T_{t_i}$}以及终点{$T_{final}$}。</li><li>对每一个手臂末端点的状态参数（$x,y,z,\theta_x,\theta_y,\theta_z$）规划一条平滑的曲线。</li><li>将规划好的手臂末端点状态的轨迹点计算IK，转换到joint-space下。</li><li>检查joint在joint-space下轨迹的可行性（有的joint的转动角度有限制或者角加速度太大手臂做不到）。</li></ol><p>具体过程如下图：<br><img src="3.png" alt=""></p><blockquote><p>Note：<br>优点：在空间中的运动轨迹比较直观。<br>缺点：计算量大，需要计算整个轨迹点的IK。</p></blockquote><h1 id="轨迹规划曲线—三次多项式"><a href="#轨迹规划曲线—三次多项式" class="headerlink" title="轨迹规划曲线—三次多项式"></a>轨迹规划曲线—三次多项式</h1><p>轨迹规划中平滑的曲线需要写成函数的形式，这样我们才能得到不同时刻的值。在这里我们用三次多项式（Cubic Polynomials）的形式来规划路径，也就是说，每两个中间点之间可以写成三次多项式的函数形式，不同轨迹区段[$t_i$ $t_{i+1}$]是不同的三次多项式。然后为了使整体的路径规划平滑，我们需要给相邻的两个区段增加限制条件，包括位置和速度（$\theta(t_i)$，$\theta(t_{i+1})$，$\dot\theta(t_i)$，$\dot\theta(t_{i+1})$）。<br><img src="4.png" alt=""></p><h2 id="解三次多项式"><a href="#解三次多项式" class="headerlink" title="解三次多项式"></a>解三次多项式</h2><ol><li><p>三次多项式的通式：<br>$$<br>\theta(\tilde t)=a_0+a_1\tilde t+a_2\tilde t^2+a_3\tilde t^3, 4\space unknown\space para: a_j \space _{j=0…3}<br>$$<br>每一个区段[$t_i$ $t_{i+1}$]都有一个这样的三次多项式，只不过每段的参数不同。</p></li><li><p>$\tilde t$的取值：<br>对每一个区段：$t\in[t_i,t_{i+1}]$<br>$\tilde t=t-t_i$，所以$\tilde t|_{t=t_i}=0$</p></li><li><p>增加边界条件：<br>首先当$t=t_i$和$t=t_{i+1}$时，这个三次多项式函数需要落在$\theta_i$和$\theta_{i+1}$上，所以有：<br>$$<br>\begin{aligned}<br>&amp;\theta(\tilde t|_{t=t_i})=\theta_i=\color{red}{a_0} \\<br>&amp;\theta(\tilde t|_{t=t_{i+1} })=\theta_{i+1}=a_0+a_1\Delta t+a_2\Delta t^2+a_3\Delta t^3 \\<br>\end{aligned}<br>$$<br>然后这个三次多项式函数在$t=t_i$和$t=t_{i+1}$时的速度也需要我们来设计，所以有：<br>$$<br>\begin{aligned}<br>&amp;\dot \theta(\tilde t|_{t=t_i})=\dot \theta_i=\color{red}{a_1} \\<br>&amp;\dot \theta(\tilde t|_{t=t_{i+1} })=\dot \theta_{i+1}=a_1+2a_2\Delta t+3a_4\Delta t^2 \\<br>\end{aligned}<br>$$</p></li><li><p>联立上面4个方程式最后解出：<br>$$<br>\begin{aligned}<br>&amp;\color{red}{a_2} = \frac{3}{\Delta t^2}(\theta_{i+1}-\theta_i)-\frac{2}{\Delta t}\dot \theta_i-\frac{1}{\Delta t}\dot \theta_{i+1} \\<br>&amp;\color{red}{a_3} = -\frac{2}{\Delta t^3}(\theta_{i+1}-\theta_i)+\frac{1}{\Delta t^2}(\dot \theta_{i+1}+\dot \theta_i)<br>\end{aligned}<br>$$</p></li><li><p>用Matrix的方式计算：<br><img src="5.png" alt=""></p></li></ol><h2 id="多段三次多项式"><a href="#多段三次多项式" class="headerlink" title="多段三次多项式"></a>多段三次多项式</h2><p>在上面的计算中，我们需要设计在边界的速度条件$\dot \theta_i$和$\dot \theta_{i+1}$，那么我们该如何设计呢？</p><ol><li>自己定义。不建议用这个方法，这样会使我们整个路径规划变得很复杂。</li><li>自动生成：<br>如果$\dot \theta_i$在$t_i$前后变号，那么$\dot \theta_i$就取0；<br>如果$\dot \theta_i$在$t_i$前后同号，那么$\dot \theta_i$就取前后两段速度的平均数；<br><img src="6.png" alt=""></li></ol><h3 id="举例：有一个中间点的路径规划"><a href="#举例：有一个中间点的路径规划" class="headerlink" title="举例：有一个中间点的路径规划"></a>举例：有一个中间点的路径规划</h3><p><img src="7.png" alt=""><br><img src="8.png" alt=""><br><img src="9.png" alt=""><br><img src="10.png" alt=""></p><h2 id="多段三次多项式通解"><a href="#多段三次多项式通解" class="headerlink" title="多段三次多项式通解"></a>多段三次多项式通解</h2><p>假设一共有N+1个点，其中有1个初始点，N-1个中间点和1个终点。那么我们一共就有N个三次多项式，每个三次多项式有4个未知参数，所以一共有4N个未知量。为了求解这4N个未知量，我们就需要4N个限制条件：</p><ul><li>每一段会有两个位置条件，所以一共有2N个位置条件；</li><li>每一个中间点会有一个速度条件和一个加速度条件，所以一共有2（N-1）个速度和加速度条件；</li><li>目前为止一共有4N-2个条件，那么最后两个条件我们可以限制起始点和终点点的速度或者是加速度，这样就有4N个条件了。</li></ul><h3 id="举例：一个RRR的机械手臂"><a href="#举例：一个RRR的机械手臂" class="headerlink" title="举例：一个RRR的机械手臂"></a>举例：一个RRR的机械手臂</h3><p>方法一：用三次多项式在Cartesian-space下规划路径：<br><img src="11.png" alt=""><br><img src="12.png" alt=""><br><img src="13.png" alt=""><br><img src="14.png" alt=""><br>方法二：用三次多项式在joint-space下规划路径：<br><img src="15.png" alt=""><br><img src="16.png" alt=""><br><img src="17.png" alt=""></p><h2 id="高阶多项式"><a href="#高阶多项式" class="headerlink" title="高阶多项式"></a>高阶多项式</h2><p>如果我们不但要规划位置和速度，还要规划加速度的话，我们就需要用到五次多项式，而不是四次多项式。因为位置、速度和加速度分别会产生2个条件，一共有6个条件，五次多项式有6个未知数。<br><img src="18.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械手臂轨迹规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂四--逆向运动学</title>
      <link href="/2020/05/11/robot-arm-4/"/>
      <url>/2020/05/11/robot-arm-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>上一讲介绍了正向运动学（Forward Kinematics），它的计算过程是给予$\theta_i$（可计算出$^{i-1}_iT$），然后求出手臂末端位置或坐标。相反，对于逆向运动学（Inverse Kinematics）来说，就是给予手臂末端位置或坐标，求得$\theta_i$。</p><h1 id="求解概念"><a href="#求解概念" class="headerlink" title="求解概念"></a>求解概念</h1><p>假设有一个6DOF的机械臂，未知的joint angles就有6个（$\theta_i$或$d_i$，$i=1,…,6$）。那么它的Transformation Matirx就可以写成这样的形式：<br>$$<br>^0_6T=<br> \left[<br>\begin{array}{ccc|c}<br>  &amp;^0_6R_{3\times3}&amp;&amp;^0P_{6 org 3\times1} \\<br>\hline<br>  0&amp;0&amp;0&amp;1<br>\end{array}<br>\right] _{4\times4}<br>$$<br>对于任何一个Transformation Matrix来说，它们都只有6个自由度，因为虽然旋转矩阵$R$里有九个数字，但是$\hat X, \hat Y, \hat Z$的长度为1，增加了3个限制条件，然后$\hat X, \hat Y, \hat Z$又要两两要垂直，又增加了3个限制条件，所以只有3个自由度，再加上移动向量$P$的3个未知数，一共就有6个自由度。为了解出这个Transformation Matrix，我们需要解出$R$和$P$，一共有12个非线性方程式，再加上6个限制条件，来解6个未知数。所以6自由度的机械臂是没有冗余的，需要用pieper准则来判断机械臂是否有解析解，后面会介绍。但是当机械臂大于6个自由度时，就会有冗余自由度，这时IK就有无数多的解，在实际应用中需要增加限制条件方能求出有效解。</p><h1 id="多重解"><a href="#多重解" class="headerlink" title="多重解"></a>多重解</h1><p>因为那12个方程式是非线性的，所以并不代表具有唯一解，机械手臂的解是由自身结构所决定的。比如，上一讲中提到的PUMA机械手臂（6 DOF），它的前3个DOF是用来控制手臂末端在空间中的位置，对于同一个位置它就有四组解，如下图：<br><img src="1.png" alt=""><br>同时，同一个位置下，手腕部位的转动姿态又有两组解：<br>$$<br>\begin{aligned}<br>&amp;\theta^{‘}_4 = \theta_4 + 180^\circ \\<br>&amp;\theta^{‘}_5 = -\theta_5 \\<br>&amp;\theta^{‘}_6 = \theta_6 + 180^\circ<br>\end{aligned}<br>$$<br>所以针对一些特定工作点，就有2x4=8组解。但是，有时因为手臂本身的几何限制或者空间限制，并不是任何一个解都可以用。当出现多组解时，我们就需要进行选择，选择的方式有：</p><ul><li>选择距离目前状态最近的解，这样最快，最省能。</li><li>选择避开障碍物的解，如果有障碍物就需要考虑进来。</li></ul><h1 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h1><p>求解Inverse Kinematics的方法有两种，<strong>解析法</strong>和<strong>数值法</strong>。解析法就是用代数（algebraic）计算Transformation Matrix并解方程的方法或着几何（geometric）法画图再运用三角函数来计算。而数值法就是是采用某种计算方法，如有限元法， 数值逼近法，插值法等得到的解，其<strong>正确性不如解析法</strong>可靠。目前大多数机械手臂都直接设计成有解析解的。</p><h2 id="举例：RRR机械手臂"><a href="#举例：RRR机械手臂" class="headerlink" title="举例：RRR机械手臂"></a>举例：RRR机械手臂</h2><p>这里以一个RRR机械手臂为例，分别介绍解析法中代数方法和几何方法计算IK问题。<br><img src="2.png" alt=""><br>首先我们计算出它的Transformation Matrix，如下：<br>$$<br>^0_3T=<br>\begin{bmatrix}<br>c_{123} &amp; -s_{123} &amp; 0 &amp; l_1c_1+l_2c_{12} \\<br>s_{123} &amp; c_{123} &amp; 0 &amp; l_1s_1+l_2s_{12} \\<br>0 &amp; 0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{bmatrix}<br>$$<br>我们的目标是得到如下的Transformation Matrix：<br>$$<br>^0_3T=<br>\begin{bmatrix}<br>c_{\phi} &amp; -s_{\phi} &amp; 0 &amp; x \\<br>s_{\phi} &amp; c_{\phi} &amp; 0 &amp; y \\<br>0 &amp; 0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{bmatrix}<br>$$</p><h3 id="几何法"><a href="#几何法" class="headerlink" title="几何法"></a>几何法</h3><p>对于这样一个简单的机械手臂来说，在一些特定的点仍然会有多重解，比如下图所示，手臂到达（x,y）点可以以蓝色折线的姿态，也可以以绿色折线的姿态。计算方式就是先运用余弦定理先计算出$\theta_2$，再利用余弦定理计算出中间角$\psi$，最后算出$\theta_1$和$\theta_3$。<br><img src="3.png" alt=""><br><img src="4.png" alt=""></p><h3 id="代数法"><a href="#代数法" class="headerlink" title="代数法"></a>代数法</h3><p><img src="5.png" alt=""><br><img src="6.png" alt=""><br><img src="7.png" alt=""></p><h2 id="Pieper’s-Solution"><a href="#Pieper’s-Solution" class="headerlink" title="Pieper’s Solution"></a>Pieper’s Solution</h2><p>Pieper准则就是说对于6自由度的机械手臂满足以下两个条件中的一个，就会有解析解。</p><ul><li>三个相邻关节轴相交于一点；</li><li>三个相邻关节轴相互平行。</li></ul><p>比如之前介绍的PUMA机械手臂，它的前三轴是用来产生移动的，后三轴是用来产生转动的，并且相交于一点，满足Pieper准则，$^0P_{6 org} = ^0P_{4 org}$<br><img src="8.png" alt=""><br>首先我们要根据最终的位置解出前三轴的角度。<br><img src="9.png" alt=""><br><img src="10.png" alt=""><br><img src="11.png" alt=""><br><img src="12.png" alt=""><br>在计算$\theta_3$时，用到了一种三角函数方程式求解的方法，如下图：<br><img src="13.png" alt=""><br>到这里，通过位置计算我们已经得到了$\theta_1，\theta_2，\theta_3$，接下来就要计算它的Orientation了。因为已经知道了$\theta_1，\theta_2，\theta_3$，所以就得到了$^0_3R$，从而推导出来$^3_6R=^0_3R^{-1}{^0_6R}$，最后我们就可以用Z—Y—Z Euler angle的方法解出$\theta_4，\theta_5，\theta_6$。但是这里要注意，我们需要把4 frame的Y轴转到5 frame的Z轴位置，这样的话5 frame对Z轴转动就相当于对4 frame的Y轴转动，然后因为4 frame的Z轴与6 frame重合，所以对6 frame的Z轴转动就相当与对4 frame的Z轴转动，但是要注意需要将4 frame转到与6 frame重合，这样就完成了Z—Y—Z的转动。这里用$\theta_4’，\theta_5’，\theta_6’$来说明用Z—Y—Z方法算出来的角度，而$\theta_4，\theta_5，\theta_6$是DH定义的角度，它们之间有一些差异。图解如下：<br><img src="14.png" alt=""><br><img src="15.png" alt=""></p><h3 id="举例：物件取放任务"><a href="#举例：物件取放任务" class="headerlink" title="举例：物件取放任务"></a>举例：物件取放任务</h3><p><img src="16.png" alt=""><br><img src="17.png" alt=""><br><img src="18.png" alt=""><br><img src="19.png" alt=""><br><img src="20.png" alt=""><br><img src="21.png" alt=""><br><img src="22.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向运动学 </tag>
            
            <tag> Inverse Kinematics </tag>
            
            <tag> Pieper Solution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂三--正向运动学</title>
      <link href="/2020/05/09/robot-arm-3/"/>
      <url>/2020/05/09/robot-arm-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在讨论正向运动学之前，我们先了解两个概念，一个是运动学（Kinematics），一个是动力学（Dynamics）。看起来名字都差不多，那么它们有什么差别呢？</p><ul><li>运动学（Kinematics）：讨论的是运动状态，未联系到产生运动的<strong>力</strong>。也就是位移，速度，加速度和时间之间的关系，比如$v=\frac{d}{dt}x$，$a=\frac{d}{dt}v$。</li><li>动力学（Dynamics）：讨论的是<strong>力</strong>和<strong>力矩</strong>是如何产生运动的。比如，$\sum F=ma$。</li></ul><p>在了解完运动学的概念后，那么什么是正向运动学呢？假设我们有一个简单的机械臂，如下图所示：<br><img src="1.png" alt=""><br>当我们知道了$l_1,l_2,l_3,\theta_1,\theta_2,\theta_3$时，通过简单的三角函数计算我们就可以一步一步的计算出机械臂末端点P所在的位置，那么这个就叫做正向运动学。反之，如果我们想要机械臂末端点P到达某个位置，那么我们就需要知道这个位置所对应的$\theta_1,\theta_2,\theta_3$，这个过程就是反向运动学（Inverse Kinematics），这个我们在下一讲介绍。</p><h1 id="机械手臂的几何描述"><a href="#机械手臂的几何描述" class="headerlink" title="机械手臂的几何描述"></a>机械手臂的几何描述</h1><p>机械手臂是由多个杆件（link）和关节（joint）所组成的。</p><ul><li>机械手臂的关节不但可以进行转动（revolute）还可以进行移动（prismatic），每个关节的运动都会沿着<strong>某特定axis</strong>进行。</li><li>机械手臂的杆件的作用就是将各个关节连接起来。</li></ul><p>为了计算出机械臂末端点所在空间的位置，我们需要一步一步的找到各个joint在空间中的位置，因此我们可以在每一个joint上建立坐标系，然后利用上一讲中介绍的Transformation Matrix来计算各个坐标系在空间中的位置，这样我们就间接的知道了各个joint的位置。</p><h2 id="第一步：建立frame"><a href="#第一步：建立frame" class="headerlink" title="第一步：建立frame"></a>第一步：建立frame</h2><p>在joint上建立坐标系的方式如下：</p><ul><li>首先要确定所有joint的$\hat Z$轴的方向，$\hat Z$轴就是这个joint转动或移动的方向。</li><li>然后再确定$\hat X_i$的方向，要沿着$a_i$的方向，$a_i$就是$\hat Z_i$和$\hat Z_{i+1}$之间的距离。但是，当$a_i=0$也就是说$\hat Z_i$和$\hat Z_{i+1}$相交时，$\hat X_i$要取和$\hat Z_i$和$\hat Z_{i+1}$两者都垂直的方向。</li><li>最后再确定$\hat Y_i$的方向，与$\hat X_i$和$\hat Z_i$两者垂直并遵循右手定则（拇指X，食指Y，中指Z）。<br><img src="2.png" alt=""></li></ul><h2 id="第二步：Denavit-Hartenberg表达法（Craig-version）"><a href="#第二步：Denavit-Hartenberg表达法（Craig-version）" class="headerlink" title="第二步：Denavit-Hartenberg表达法（Craig version）"></a>第二步：Denavit-Hartenberg表达法（Craig version）</h2><p>Denavit-Hartenberg表达法简称为DH表达法，它可以用4个参数来表达两个joint之间的关系。因此，如果将所有joint的关系整合起来形成一个表格，那么这个表格就可以用来表达完整的机械手臂，我们把这个表格叫做DH表，那4个参数分别为：$\alpha,a,d,\theta$。</p><ul><li>$\alpha_{i-1}$：是两个joint之间的夹角，计算方法是沿着$\hat X_{i-1}$的方向看过去，从$\hat Z_{i}$转到$\hat Z_{i-1}$的角度，顺时针为负，逆时针为正。</li><li>$a_{i-1}$：是两个joint之间的距离，计算方法是沿着$\hat X_{i-1}$的方向看过去，$\hat Z_{i-1}$到$\hat Z_i$的距离，可正可负。</li><li>$\theta_i$：对于转动的joint来说，这个值是变量。计算方法是沿着$\hat Z_{i}$的方向看过去，从$\hat X_{i}$转到$\hat X_{i-1}$的角度，顺时针为负，逆时针为正。</li><li>$d_i$：对于移动的joint来说，这个值是变量。计算方法是沿着$\hat Z_{i}$的方向看过去，从$\hat X_{i-1}$到$\hat X_{i}$的距离，可正可负。<br><img src="3.png" alt=""></li></ul><h2 id="第三步：计算每个joint之间的Transformation-Matrix"><a href="#第三步：计算每个joint之间的Transformation-Matrix" class="headerlink" title="第三步：计算每个joint之间的Transformation Matrix"></a>第三步：计算每个joint之间的Transformation Matrix</h2><p>接下来我们就要计算出每个joint之间的Transformation Matrix，计算方式如下：<br>$$<br>^{i-1}_iT=T_{\hat X_{i-1} }(\alpha_{i-1})T_{\hat X_R}(a_{i-1})T_{\hat Z_Q}(\theta_i)T_{\hat Z_P}(d_i) \\<br>= \begin{bmatrix}<br>c\theta_i &amp; -s\theta_i &amp; 0 &amp; a_{i-1}  \\<br>s\theta_ic\alpha_{i-1} &amp; c\theta_ic\alpha_{i-1} &amp; -s\alpha_{i-1} &amp; -s\alpha_{i-1}d_i  \\<br>s\theta_is\alpha_{i-1} &amp; c\theta_is\alpha_{i-1} &amp; c\alpha_{i-1} &amp; c\alpha_{i-1}d_i \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$$<br><img src="4.png" alt=""><br>计算的过程都是遵循上一讲所说的Eular Angles的情况，所以计算过程都是右乘。首先呢，先将i-1 frame沿着X轴转动到R frame，再沿着X轴移动到Q frame，接着再沿着Z轴转动到P frame，最后呢再沿着Z轴移动到i frame，就得到了我们最终想要的$^{i-1}_iT$。<br>同样的，它也可以进行多个Transformation Matrix连乘：<br>$$<br>^{i-1}_iT=^{0}_1T^{1}_2T^{2}_3T…^{n-2}_{n-1}T^{n-1}_nT<br>$$</p><blockquote><p>Note: 通过这种方式我们就可以得到任意joint相对于基坐标（0 frame）的Transformation Matrix，从而得到任意joint相对于基坐标的位置。</p></blockquote><h3 id="举例-PUMA-560-1"><a href="#举例-PUMA-560-1" class="headerlink" title="举例 PUMA 560 -1"></a>举例 PUMA 560 -1</h3><h4 id="建立frame"><a href="#建立frame" class="headerlink" title="建立frame"></a>建立frame</h4><p>PUMA 560-1机械手臂坐标系的建立如下图所示，当然这并不是唯一的方法，X轴，Y轴，Z轴的方向都可以和下图所示的方法相反，只不过不同的方法会建立不同的DH表。<br><img src="5.png" alt=""></p><blockquote><p>Note: </p><ol><li>0 frame是基坐标，可以定在任意位置。</li><li>$\hat Z_1$与$\hat Z_2$相交，所以$\hat X_1$的方向要垂直与$\hat Z_1$和$\hat Z_2$</li></ol></blockquote><h4 id="建立DH表"><a href="#建立DH表" class="headerlink" title="建立DH表"></a>建立DH表</h4><p>DH表如下图所示。因为我们的手臂有6个DOF，所以i的取值就从1-6。1代表1 frame，2代表2 frame，以此类推。首先看第一行，因为0 frame和1 frame完全重合，所以$\alpha_0, a_0, d_1$都是0，唯一可能会变的就是$\theta_1$这个变量。第二行中，沿着$\hat X_{1}$的方向看过去，从$\hat Z_{2}$转到$\hat Z_{1}$的角度为顺时针$90^\circ$，所以$\alpha_1=-90^\circ$。$\hat Z_{1}$到$\hat Z_{2}$的距离为0，所以$a_1=0$，$\hat X_{1}$到$\hat X_{2}$的距离为0，所以$d_1=0$，$\theta_2$同样是变量。以此类推就可以得到整个DH表。<br><img src="6.png" alt=""></p><h4 id="计算Transformation-Matrix"><a href="#计算Transformation-Matrix" class="headerlink" title="计算Transformation Matrix"></a>计算Transformation Matrix</h4><p>计算的方式就是将DH表里的参数带入之前介绍的计算Transformation Matrix的公式里，结果如下图：<br><img src="7.png" alt=""><br><img src="8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正向运动学 </tag>
            
            <tag> Forward Kinematics </tag>
            
            <tag> DH表达法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂二--旋转矩阵和变换矩阵的计算</title>
      <link href="/2020/05/05/robot-arm-2/"/>
      <url>/2020/05/05/robot-arm-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="旋转矩阵与转角的关系"><a href="#旋转矩阵与转角的关系" class="headerlink" title="旋转矩阵与转角的关系"></a>旋转矩阵与转角的关系</h1><p>上一讲中我们介绍了质点沿着某一坐标轴旋转的旋转矩阵的计算方法，但是在更普遍的情况下，质点的旋转并不是沿着某一坐标轴，而可能是空间中的任意轴。所以这一讲我们将介绍如何通过拆解为沿坐标轴旋转的方式来计算任意旋转矩阵。</p><p>拆解的方式有两种：</p><ol><li>Fixed angles – 根据一个固定不动的坐标系进行旋转</li><li>Euler angles – 对转动后的坐标系再此进行旋转</li></ol><h2 id="Fixed-angles"><a href="#Fixed-angles" class="headerlink" title="Fixed angles"></a>Fixed angles</h2><p>如下图所示，A frame是固定不变的坐标系，我们先沿着$\hat{X}$轴旋转$\gamma$角度，再沿着$\hat{Y}$轴旋转$\beta$角度，最后沿着$\hat{Z}$轴旋转$\alpha$角度得到了B frame。<br><img src="1.png" alt=""><br>旋转矩阵的计算方式如下：<br>$$<br>\begin{aligned}<br>&amp;^A_BR_{XYZ}(\gamma,\beta,\alpha) =<br>R_Z(\alpha)R_Y(\beta)R_X(\gamma) \\<br>&amp;=    \begin{bmatrix}<br>    c\alpha c\beta &amp; c\alpha s\beta s\gamma - s\alpha c\gamma &amp; c\alpha s\beta c\gamma + s\alpha s\gamma \\<br>    s\alpha c\beta &amp; s\alpha s\beta s\gamma + c\alpha c\gamma &amp; s\alpha s\beta c\gamma - c\alpha s\gamma \\<br>    -s\beta &amp; c\beta s\gamma &amp; c\beta c\gamma<br>    \end{bmatrix} \\<br>&amp;= \begin{bmatrix}<br>r_{11} &amp; r_{12} &amp; r_{13}  \\<br>r_{21} &amp; r_{22} &amp; r_{23}  \\<br>r_{31} &amp; r_{32} &amp; r_{33}  \\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><blockquote><p>Note: Fixed angles下，旋转矩阵采用的是左乘的方式计算。</p></blockquote><p>当我们已知旋转矩阵R时，怎么反推出来旋转的角度呢？根据$r_{31}$元素的值我们可以直接算出$\beta$角，然而$\beta$角的取值会有如下三种情况：<br>如果$\beta \neq \pm90^\circ$：<br>$$<br>\begin{aligned}<br>\beta &amp;= Atan2(-r_{31}, \sqrt{r_{11} ^2 + r_{21} ^2}) \\<br>\alpha &amp;= Atan2(r_{21}/c\beta, r_{11}/c\beta) \\<br>\gamma &amp;= Atan2(r_{32}/c\beta, r_{33}/c\beta)<br>\end{aligned}<br>$$<br>如果$\beta = 90^\circ$：<br>$$<br>\begin{aligned}<br>&amp;\alpha = 0^\circ \\<br>&amp;\gamma = Atan2(r_{12},r_{22})<br>\end{aligned}<br>$$<br>如果$\beta = -90^\circ$：<br>$$<br>\begin{aligned}<br>&amp;\alpha = 0^\circ \\<br>&amp;\gamma = -Atan2(r_{12},r_{22})<br>\end{aligned}<br>$$</p><blockquote><p>Note: 当$\beta \neq \pm90^\circ$时，就发生了欧拉旋转的万向锁问题。这个问题在欧拉旋转中总是会发生，无论是Fixed angles还是Eular angls，无论是X-Y-Z，Y-X-Z，Z-Y-X等等所有旋转都会发生。根据图示可以更好的理解，当第二次旋转为$\pm90^\circ$时，第三次要旋转的轴一定就是第一次旋转的轴，这样的话就会导致损失一个自由度，所以直接给第一次旋转的角度$\alpha$赋值为0，放弃这个自由度，但是计算结果是正确的。</p></blockquote><h2 id="Euler-angles（Z-Y-X）"><a href="#Euler-angles（Z-Y-X）" class="headerlink" title="Euler angles（Z-Y-X）"></a>Euler angles（Z-Y-X）</h2><p>如下图所示，A frame是我们即将要旋转的坐标系，首先我们先沿着$\hat{Z}$轴旋转$\alpha$角度，再沿着旋转之后的坐标系的$\hat{Y}$轴旋转$\beta$角度，最后再沿着$\hat{X}$轴旋转$\gamma$角度得到了B frame。<br><img src="2.png" alt=""><br>旋转矩阵的计算方式如下：<br>$$<br>\begin{aligned}<br>&amp;^A_BR_{ZYX}(\alpha,\beta,\gamma) =<br>R_Z(\alpha)R_Y(\beta)R_X(\gamma) \\<br>&amp;=    \begin{bmatrix}<br>    c\alpha c\beta &amp; c\alpha s\beta s\gamma - s\alpha c\gamma &amp; c\alpha s\beta c\gamma + s\alpha s\gamma \\<br>    s\alpha c\beta &amp; s\alpha s\beta s\gamma + c\alpha c\gamma &amp; s\alpha s\beta c\gamma - c\alpha s\gamma \\<br>    -s\beta &amp; c\beta s\gamma &amp; c\beta c\gamma<br>    \end{bmatrix} \\<br>&amp;= \begin{bmatrix}<br>r_{11} &amp; r_{12} &amp; r_{13}  \\<br>r_{21} &amp; r_{22} &amp; r_{23}  \\<br>r_{31} &amp; r_{32} &amp; r_{33}  \\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><blockquote><p>Note: Euler angles下，旋转矩阵采用的是右乘的方式计算。</p></blockquote><p>我们发现与X-Y-Z fixed angle得到同样的旋转矩阵，所以Fix angle下以X-Y-Z来转就等于Eular angle下以Z-Y-X来转。因为旋转矩阵是一样的，那么反推旋转角度的计算方式和Fixed angle也是一样的。</p><h2 id="Euler-angles（Z-Y-Z）"><a href="#Euler-angles（Z-Y-Z）" class="headerlink" title="Euler angles（Z-Y-Z）"></a>Euler angles（Z-Y-Z）</h2><p>Euler angles还有一种旋转方式就是Z-Y-Z，即我们先沿着$\hat{Z}$轴旋转$\alpha$角度，再沿着旋转之后的坐标系的$\hat{Y}$轴旋转$\beta$角度，最后再沿着$\hat{Z}$轴旋转$\gamma$角度。如下图所示：<br><img src="3.png" alt=""><br>旋转矩阵的计算方式如下：<br>$$<br>\begin{aligned}<br>&amp;^A_BR_{ZYZ}(\alpha,\beta,\gamma) =<br>R_Z(\alpha)R_Y(\beta)R_Z(\gamma) \\<br>&amp;=    \begin{bmatrix}<br>    c\alpha c\beta c\gamma - s\alpha s\gamma &amp; -c\alpha c\beta s\gamma - s\alpha c\gamma &amp; c\alpha s\beta \\<br>    s\alpha c\beta c\gamma + c\alpha s\gamma &amp; -s\alpha c\beta s\gamma + c\alpha c\gamma &amp; s\alpha s\beta \\<br>    -s\beta c\gamma &amp; s\beta s\gamma &amp; c\beta<br>    \end{bmatrix} \\<br>&amp;= \begin{bmatrix}<br>r_{11} &amp; r_{12} &amp; r_{13}  \\<br>r_{21} &amp; r_{22} &amp; r_{23}  \\<br>r_{31} &amp; r_{32} &amp; r_{33}  \\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><blockquote><p>Note: Euler angles下，旋转矩阵采用的是右乘的方式计算。</p></blockquote><p>要计算旋转的角度，我们首先根据$r_{33}$元素的值算出$\beta$角，然而$\beta$角的取值依然会有如下三种情况：<br>如果$\beta \neq 0^\circ or 180^\circ$：<br>$$<br>\begin{aligned}<br>\beta &amp;= Atan2(\sqrt{r_{31} ^2 + r_{32} ^2}, r_{33} ) \\<br>\alpha &amp;= Atan2(r_{23}/s\beta, r_{13}/s\beta) \\<br>\gamma &amp;= Atan2(r_{32}/s\beta, -r_{31}/s\beta)<br>\end{aligned}<br>$$<br>如果$\beta = 0^\circ$：<br>$$<br>\begin{aligned}<br>&amp;\alpha = 0^\circ \\<br>&amp;\gamma = Atan2(-r_{12},r_{11})<br>\end{aligned}<br>$$<br>如果$\beta = 180^\circ$：<br>$$<br>\begin{aligned}<br>&amp;\alpha = 0^\circ \\<br>&amp;\gamma = -Atan2(r_{12},-r_{11})<br>\end{aligned}<br>$$</p><h1 id="Transformation-matrix"><a href="#Transformation-matrix" class="headerlink" title="Transformation matrix"></a>Transformation matrix</h1><p>因为刚体在空间中的状态有移动$\vec{P}$和转动$R$两种，为了方便计算我们需要将这两种状态整合到一个矩阵里计算，因此我们引入了变换矩阵：<br>$$<br>^A_BT=<br> \left[<br>\begin{array}{ccc|c}<br>  &amp;^A_BR_{3\times3}&amp;&amp;^AP_{B org 3\times1}\\<br>\hline<br>  0&amp;0&amp;0&amp;1<br>\end{array}<br>\right] _{4\times4}<br>$$</p><h2 id="Transformation-matrix的应用"><a href="#Transformation-matrix的应用" class="headerlink" title="Transformation matrix的应用"></a>Transformation matrix的应用</h2><p>Transformation matrix的应用有两种情况：一种是已知某个质点在一个坐标系的位置，通过两个坐标系的变换矩阵来计算这个质点在另一个坐标系的位置；另一种是在同一个坐标系下，计算某质点经过移动和旋转后的新的坐标。</p><p>在第一种情况下，例如，已知P点在B frame下的坐标，以及B frame对A frame的Transformation matrix，那么P点在A frame的坐标就是：<br>$$<br>\begin{bmatrix}<br>^AP \\<br>1<br>\end{bmatrix} =<br>\begin{bmatrix}<br>  &amp;^A_BR&amp;&amp;^AP \\<br>  0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>^BP \\<br>1<br>\end{bmatrix} =<br>\begin{bmatrix}<br>^A_BR^BP+^AP_{Borg} \\<br>1<br>\end{bmatrix}<br>$$</p><blockquote><p>Note: Tranforamtion Matrix是可以连续操作的:$^A_BT=^A_CT^C_DT^D_BT$<br>这样的话，我们只要是知道任何坐标系之间的T，就可以知道任意点在不同坐标系下的坐标。</p></blockquote><p>在第二种情况下，如果质点是先转动再移动的话，那么计算方式和第一种情况相同，因为我们看最终P点在A frame下的表达式：$^AP_2 = R^AP_1+P$，P点先左乘R进行了转动，才加上偏移量进行了移动，只不过这里的P和R都是相对于自身坐标系来说的。如果是先移动再转动的话，表达式应该是这样：$^AP_2 = R(^AP_1+P)$，结果完全不同。</p><h2 id="Transformation-matrix的运算"><a href="#Transformation-matrix的运算" class="headerlink" title="Transformation matrix的运算"></a>Transformation matrix的运算</h2><ol><li>连续运算<br>$$<br>^AP=^A_BT^BP=^A_BT(^B_CT^CP)=^A_BT^B_CT^CP<br>$$</li><li>反矩阵（计算过程省略）</li></ol><p>$$<br>^A_BT^{-1}=<br>\begin{bmatrix}<br>  &amp;^A_BR^T&amp;&amp;-^A_BR^T{^AP_{Borg} } \\<br>  0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p><ol start="3"><li><p>连续运算，求未知T<br>已知$^U_DT=^U_AT^A_DT=^U_BT^B_CT^C_DT$，如图：<img src="4.png" alt=""><br>如果$^C_DT$不知道，那么<br>$$<br>^C_DT=(^U_BT^B_CT)^{-1}{^U_AT^A_DT}<br>$$</p></li><li><p>连续运算法则<br>假设有两个frame，A和B，然而B frame需要经过$T_1$，$T_2$，$T_3$三次按照转轴旋转和移动才能与A重合。那么，如果B frame是按照A frame的转轴旋转，$^A_BT=T_3T_2T_1I$，要按照左乘的规则，这就是前面讲的fixed angles的情况；如果B frame是按照B frame自身的转轴旋转，$^A_BT=IT_1T_2T_3$，要按照右乘的规则，这就是前面讲的Euler angles的情况。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rotation Matrix </tag>
            
            <tag> Transformation Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械手臂一--刚体的运动状态</title>
      <link href="/2020/05/04/robot-arm-1/"/>
      <url>/2020/05/04/robot-arm-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是以林沛群老师在coursera上的课程<a href="https://www.coursera.org/learn/robotics1" target="_blank" rel="noopener">机器人学一</a>为参考，进行归纳整理。</p></blockquote><h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>刚体在空间中的运动方式有两种，一种是移动，一种是转动，它们各有3个DOF。对于移动来说，它可以沿着$\hat{X}$轴，$\hat{Y}$轴和$\hat{Z}$轴移动， 同样的，转动也可以沿着$\hat{X}$轴，$\hat{Y}$轴和$\hat{Z}$轴进行转动。为了描述刚体在空间中的运动状态，我们通常会在它的质心位置建立一个坐标系（frame）, 通过得到这个坐标系与世界坐标系之间的关系，我们可以知道这个刚体在空间中的姿态。</p><h1 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h1><p>刚体的移动可以用向量$\vec{P}$来描述，它即明确了移动的方向，又说明了移动的大小。如下图：<br><img src="1.png" alt=""><br>因为位置是相对的，为了表明$\vec{P}$是以A frame为基坐标上B frame的位置，我们通常写为$^AP_B org$，其中org指的是B frame的原点，即刚体的质心。</p><h1 id="转动"><a href="#转动" class="headerlink" title="转动"></a>转动</h1><p>刚体的转动需要用三个向量来描述，因此我们将它写成矩阵的形式，并将这个矩阵称之为旋转矩阵（Rotation Matrix），用$^A_BR$来表示（B frame相对于A frame）。$^A_BR$的三个columns其实是B frame的$\hat{X}$轴，$\hat{Y}$轴以及$\hat{Z}$轴方向的单位向量在A frame下的投影，因此旋转矩阵的三个cloumns的长度都为1。如图：<br><img src="2.png" alt=""></p><h2 id="旋转矩阵的特性"><a href="#旋转矩阵的特性" class="headerlink" title="旋转矩阵的特性"></a>旋转矩阵的特性</h2><p>旋转矩阵有如下特性：</p><ul><li>$^A_BR$=$^B_AR^T\to$ B对A的旋转矩阵就相当于A对B的旋转矩阵的转置</li><li>$^A_BR^T$=$^A_BR^{-1}$=$^B_AR\to$ 旋转矩阵的逆矩阵等于它的转置。这个特性非常有用，因为逆矩阵的计算往往需要很大的计算量，有了这个特性，我们就可以很容易的得到旋转矩阵的逆矩阵。</li></ul><h2 id="旋转矩阵的使用"><a href="#旋转矩阵的使用" class="headerlink" title="旋转矩阵的使用"></a>旋转矩阵的使用</h2><p>旋转矩阵除了可以描述B frame相对于A frame的姿态以外，也可以计算向量在不同frame下的坐标。比如有一个在B frame下的向量$^BP$，那么它在A frame下的坐标就可以这样得到: $^AP$=$^A_BR$$^BP$<br>以上的应用都是在已知两个frame的旋转矩阵下进行的，当有一个向量要在同一个frame下沿某个轴转动某个角度时，我们就需要计算出旋转矩阵，计算方式如下：<br>$$<br>R_{ {\hat{X} }_A}(\theta)=<br>    \begin{bmatrix}<br>    1 &amp; 0 &amp; 0 \\<br>    0 &amp; cos\theta &amp; -sin\theta \\<br>    0 &amp; sin\theta &amp; cos\theta<br>    \end{bmatrix}<br>$$$$<br>R_{ {\hat{Y} }_A}(\theta) =<br>    \begin{bmatrix}<br>    cos\theta &amp; 0 &amp; sin\theta \\<br>    0 &amp; 1 &amp; 0 \\<br>    -sin\theta &amp; 0 &amp; cos\theta<br>    \end{bmatrix}<br>$$$$<br>R_{ {\hat{Z} }_A}(\theta) =<br>    \begin{bmatrix}<br>    cos\theta &amp; -sin\theta &amp; 0 \\<br>    sin\theta &amp; cos\theta &amp; 0 \\<br>    0 &amp; 0 &amp; 1<br>    \end{bmatrix}<br>$$<br>例如有点$^AP$对$\hat{X}_A$轴转动$\theta$角度后得到了点$^AP’$,那么点$^AP’$的坐标就是：$$<br>    ^AP’=R_{ {\hat{X} }_A}(\theta)^AP<br>$$注意：点$^AP’$的坐标是基于{A}的，而不是旋转后的坐标{A’}的。</p>]]></content>
      
      
      <categories>
          
          <category> 机械手臂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刚体运动 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
